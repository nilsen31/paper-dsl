 
 
\documentclass[11pt,english,ngerman, headsepline]{scrreprt}
\usepackage{lmodern}
\renewcommand{\sfdefault}{lmss}
\renewcommand{\ttdefault}{lmtt}
\usepackage[T1]{fontenc}

\usepackage{listings}

\usepackage[utf8]{inputenc} \usepackage[a4paper]{geometry}
\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=3cm,rmargin=2.75cm,headheight=1cm,headsep=0.666cm,footskip=1cm}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{babel}
  \usepackage{tipa}
\usepackage{verbatim} 
\usepackage{float}  
\usepackage{courier}
\usepackage{url}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage[square,sort,numbers]{natbib} \usepackage[utf8]{inputenc}
\usepackage{graphicx} 
\usepackage[xindy,toc]{glossaries}
 
 
 
\input{formating/formating.tex}

\parindent 0pt

\begin{document} 


\input{deckblatt/deckblatt.tex}

\selectlanguage{ngerman}%
\tableofcontents{}

\pagestyle{scrheadings}    %Kopfzeile ein


% ==========================================================================
% DOCUMENT START
% ==========================================================================

\chapter{Einleitung} 



\section{Motivation}

Das Wort “Abstraktion” bezeichnet meist den induktiven Denkprozess des
Weglassens von Einzelheiten und des Überführens auf etwas Allgemeineres oder
Einfacheres [...] also [...] jenen Prozess, der Informationen soweit auf ihre
wesentlichen Eigenschaften herab setzt, dass sie psychisch überhaupt weiter
verarbeitet werden können. (nach \cite{wikiAbsraktion}) Die grundlegenden
Abstraktionsstufen in der Informatik sind wie folgt aufgeteilt: Die unterste
Ebene ohne Abstraktion ist die der elektronischen Schaltkreise, die elektrische
Signale erzeugen, kombinieren und speichern. Darauf aufbauend existiert die
Schaltungslogik. Die dritte Abstraktionsschicht ist die der Rechnerarchitektur.
Danach kommt eine der obersten Abstraktionsschichten: “Die Sicht des
Programmierers”, der den Rechner nur noch als Gerät ansieht, das Daten speichert
und Befehle ausführt, dessen technischen Aufbau er aber nicht mehr im Einzelnen
zu berücksichtigen braucht. (nach S. 67 \cite{rechenberg2000informatik}). Diese
Beschreibung von Abstraktion lässt sich auch auf Programmiersprachen übertragen.
Nur wenige programmieren heute direkt Maschinencode, weil die
Programmiersprachen der dritten Generation (3GL) soviel Abstraktionsgrad bieten,
dass zwar kein bestimmtes Problem, aber dessen Lösung beschrieben werden kann.

Die Lösung des Problems muss genau in der Sprache beschrieben werden und setzt
das Verständnis und die Erfahrung in der Programmiersprache und deren
Eigenheiten zur Problemlösung voraus. Das Verständnis des eigentlichen Problems,
dass es mit Hilfe von Software zu lösen gilt, liegt nicht immer zu 100\% bei dem
Programmierer, der es mit Java oder C\# bzw. einer 3GL lösen soll. Komplexe
Probleme z.B. in der Medizin, der Architektur oder im Versicherungswesen sind
oft so umfangreich, dass die Aufgabe des “Requirements Engeneering”
hauptsächlich darin besteht, zwischen dem Auftragnehmer und Auftraggeber eine
Verständnisbrücke zu bauen. Diese Brücke ist auf der einen Seite mit
Implementierungsdetails belastet und auf der anderen mit domänenspezifischem
Wissen (Fach- oder Expertenwissen). Die Kommunikation der beiden Seiten kann
langfristig durch eine DSL begünstigt werden, da eine Abstrahierung des
domänenspezifischen Problems angestrebt wird. Die Isolation der eigentlichen
Businesslogik und eine intuitiv verständliche Darstellung in textueller Form
kann sogar soweit gehen, dass der Domänenexperte die Logik in hohem Maße selbst
implementieren kann, weil er nicht mit den Implementierungsdetails derselben und
den syntaktischen Gegebenheiten einer turingvollständigen
General-Purpose-Language wie Java oder C\# abgelenkt wird. Im Idealfall kann er
die gewünschten Anforderungen besser abbilden.(vlg. \cite{heiseMPS2}). Beispiele
für DSL sind z.B.: Musiknoten auf einem Notenblatt, Morsecode oder
Schachfigurbewegungen (“Bauer e2-e4”) bis hin zu folgendem Satz: “wenn (Kunde
Vorzugsstatus hat) und (Bestellung Anzahl ist größer als 1000 oder Bestellung
ist neu) dann ... ”. “Eine domänenspezifische Sprache ist nichts anderes als
eine Programmiersprache für eine Domäne. Sie besteht im Kern aus einem
Metamodell einer abstrakten Syntax, Constraints (Statischer Semantik) und einer
konkreten Syntax. Eine festgelegte Semantik weist den Sprachelementen eine
Bedeutung zu.” (vlg. S.30 \cite{mdaDPunkt}). 

Im Sprachsektor des Technologieradars (Juli 2011 von
Thoughtworks)\footnote{http://www.thoughtworks.com/radar}
sind die domänenspezifischen Sprachen unverändert nahe dem Zentrum
angesiedelt. Thoughtworks ist der Meinung, dass DSL eine alte Technologie ist
und bei Entwicklern einen unterschätzten Stellenwert
hat. (nach \cite{thoughtworks-tr}) Diese Quelle steht aber unter Vorbehalt in
Hinblick auf den Verkauf des Buches von Martin Fowler (Chief Scientist von
Thoughtworks) und Rebecca Parsons (CTO von Thoughtworks) über DSLs.\footnote{Domain Specific
Languages, Addison Wesley 2011} 
 
\section{Begriffserklärung}
Eine DSL beinhaltet ein Metamodell. In einer Domänengrammatik gibt es das
Konzept an sich, das beschrieben werden soll. Konzepte können Daten, Strukturen
oder Anweisungen bzw. Verhalten und Bedingungen sein. Das Metamodell oder auch
das Semantische Modell bestehen aus einem Netzwerk vieler Konzepte. Das Paradigma
“Language Orientated Programming” (LOP) identifiziert ein Vorgehen in der
Programmierung, bei dem ein Problem nicht mit einer GPL (general purpose
language) angegangen wird, sondern bei dem zuerst domänenspezifische Sprachen
entworfen werden, um dann durch diese das Problem zu lösen. Zu diesem Paradigma
gehört auch die Entwicklung von domänenorientierten Sprachen und intuitive
Programmierung (intentional programming). “Intentional Programmierung ist ein
Programmierparadigma. Sie bezeichnet den Ansatz, vom herkömmlichen Quelltext als
alleinige Spezifikation eines Programms abzurücken, um die Intentionen des
Programmierers durch eine Vielfalt von jeweils geeigneten
Spezifikationsmöglichkeiten in besserer Weise auszudrücken.” (vlg.
\cite{wikiIntentional}) Es werden zwei Arten von DSLs unterschieden
\cite{fowler2011domain}. 


\section{Aufgabenstellung }
%(kurz, knapp, präzise) und Erwartungen

Das Paradigma der sprachorientierten Programmierung und die damit verbundenen
Konzepte der domänenorientierten Programmierung sollen in dieser Arbeit
analysiert und geprüft werden. 


Eine einfache DSL soll mit Hilfe von
Groovy-Metaprogramming als interne DSL entworfen werden.


Dabei stellen sich folgende Fragen: Wie effizient ist die Erstellung einer DSL
mittels der Programmiersprache Groovy (Kapitel \ref{reaktionProgrammierer}) und wie
reagiert der Domänenexperte auf die DSL (Kapitel \ref{reaktionExperte})?

Domänenexperten, die keine Erfahrung mit Programmierung haben, sollen an
interne DSLs für deren bekannte Domäne herangeführt werden, um diese
anschließend nach Lesbarkeit, intuitivem Verständnis und Flexibilität zu
bewerten. Dabei bekommen die Probanden mehrere Aufgaben, die mit den
gegebenen DSLs zu lösen sind. 
 
\section{Gliederung}

Im theoretischen Teil stellt diese Arbeit eine Abhandlung über die Grundlagen
des ``sprachorientierten Programmierparadigmas'' (LOP) dar und die
damit verbundene Metaprogrammierung speziell für die Programmiersprache ``Groovy''.

Der praktische Teil befasst sich mit der Anwendung dieses Paradigmas. Der Autor
entwirft dazu eine interne DSL in Groovy und erklärt die Vorgehensweise von der
Idee bis zur Implementierung.
Anschließend findet eine Auswertung bzw. Bewertung des Paradigmas und
dessen Nutzen statt.
 
\section{Abgrenzung}
Der Fokus dieser Arbeit soll auf die textuelle und nicht auf die graphische
Repräsentation von DSLs abzielen. “Natural language processing” soll nur
oberflächlich betrachtet werden. Der praktische Teil berichtet ausschließlich
über die Groovy-Metaprogrammierung. 
Es werden nur interne DSLs betrachtet und es findet kein Vergleich zu externen
DSLs statt. 

\chapter{ Sprachorientierte Programmierung} 

Ein Programmierer einer Anwendung für die Browser-Platform benutzt viele
Sprachen, die alle für einen bestimmten Zweck eingesetzt werden: HTML für die
Struktur der Anwendung, CSS für die visuelle Repräsentation dieser Struktur
und SQL um Daten aus der Datenbank abzufragen bzw. aufzuwerten. Der Entwickler muss sich dann für
ein Web-Framework entscheiden, das in einer GPL wie
Java, Ruby oder PHP geschrieben ist. Nicht zuletzt ist Javascript eine
zusätzliche Sprache, die Client oder auch Serverseitig\footnote{nodejs.org}
eingesetzt wird. 
Das Paradigma sprachorientierte Programmierung ermuntert den Programmier dazu,
eigene Sprachen zu entwerfen, die den jeweiligen Problembereich explizit
beschreiben.

``Language oriented programming (LOP) is about describing a system through
multiple DSLs[\ldots]LOP is a style of development which operates about
the idea of building software around a set of DSLs''.(vlg.
\cite{fowler2005language})

Sprachorientierte Programmierung ist nach Fowlers Beschreibung ein Vorgehen,
bei dem eine Programmiersprache sich aus mehreren Unter-Programmiersprachen
zusammensetzt, deren Funktionen mit definierten Sprachmodellen beschrieben
werden.
Diese Sprachmodelle sollen die fachlichen Probleme auf eine
natürliche Art beschreiben können, ohne dabei mehr zu beschreiben als das
Fachgebiet betrifft. Dabei liegt der Fokus auf der Problembeschreibung und nicht
auf der Lösungsbeschreibung.

In dem oft zitierten Paper beschreibt Fowler ein kleines Programm, das dazu
dient Textdateien, die eine bestimmte Struktur haben, in Objektinstanzen zu
überführen.
Eine EDI-Nachricht \footnote{http://en.wikipedia.org/wiki/EDIFACT} (Electronic
Data Interchange) ist ein Beispiel dafür (Listing \ref{edimsg.txt}).

\lstinputlisting[caption={EDIFACT Nachricht für einen Verfügbarkeitsanfrage},
label={edimsg.txt},style=default]{code/edimsg.txt}

Je nachdem wie z.B. die ersten drei Zeichen einer Zeile sind, wird beim
Parser eine bestimmte ``Parsing-Strategie'' angewendet. 
Die angewendete Strategie\cite{gamma1995design} wird dann dazu verwendet, um den
Rest der Zeile auszulesen. Diese Strategie kann zusätzlich folgendermaßen
konfiguriert werden:
Die ersten drei Zeichen an sich, die Zielklasse die je nach den ersten drei Zeichen mit den restlichen Daten der
Zeile als Klassenvariablenwerte instanziiert werden soll und vor allem an
welcher Stelle der Zeile der Wert einer bestimmten Klassenvariable vorkommt.

Mit diesem kleinen Programm wurde eine Abstraktion gebaut, die durch
Konfiguration der Strategien spezifiziert werden kann.
Also um die Abstraktion zu benutzen, müssen die Strategien konfiguriert werden
und deren Instanzen an den Reader-Treiber übergeben werden  (Listing
\ref{readerstrategyAndDriver}).
 

\lstinputlisting[caption={Instanzen der verschiedenen Strategien},
label={readerstrategyAndDriver},style=default]{code/readerstrategyAndDriver.java}

Um diese Konfigurationen besser konfigurierbar zu machen, ohne immer neuen
Bytecode generieren zu müssen könnte man eine
YAML\footnote{http://de.wikipedia.org/wiki/YAML}-Datei schreiben und diese als
Input für die Strategiekonfiguration benutzen  (Listing
\ref{readerstrategyAndDriverYAML.txt}).
 
\lstinputlisting[caption={Instanzen der verschiedenen Strategien - YAML},
label={readerstrategyAndDriverYAML.txt},style=default]{code/readerstrategyAndDriverYAML.txt}

Ein Domänenexperte, der etwas vom Edifact-Parsen versteht, kann ohne fundierte
Programmierkentnisse die YAML Datei interpretieren.
Der Inhalt dieser YAML-Datei ist eine kleine Sprachinstanz. Die
konkrete Syntax ist das YAML Format. Eine andere konkrete Syntax könnte
das XML Format sein. Die abstrakte Syntax ist die Basisstruktur: ``Mehrere
Abbildungen von Zeilentypen auf Klassen, jeweils identifiziert durch drei
Buchstaben und eine Postitionsbestimmung der Klassenvariablen innerhalb der
Nachricht''.
Egal ob in XML oder in YAML, die abstrakte Syntax bleibt immer gleich.

Wenn eine minimalistische Syntax eine Vorraussetzung für eine DSL ist, kann man
die YAML-Datei auch in Ruby darstellen (Listing
\ref{readerstrategyAndDriverRuby}). Das hat zur Folge, dass der Inhalt der DSL
mit einem Ruby Interpreter gelesen und verarbeitet werden kann. Wenn auch der
andere Code in Ruby geschrieben sein würde (Stragie Implementation,
AddFieldExtractor, AddStrategy, \ldots), dann wäre Code Listing
\ref{readerstrategyAndDriverRuby} eine interne DSL und Ruby die Wirtssprache,
also eine Untermenge von Ruby und eine konkrete- zu der abstrakten Syntax.
 

\lstinputlisting[caption={Instanzen der verschiedenen Strategien - RUBY},
label={readerstrategyAndDriverRuby},style=default]{code/readerstrategyAndDriverRuby.txt}

%TODO language workbenches vorstellen

\section{Domain Specific Languages}
  
Eine domänenspezifische Sprache (engl. domain-specific language, DSL) ist, im
Gegensatz zu gängigen Programmiersprachen, auf ein ausgewähltes
 Problemfeld (die Domäne) spezialisiert. Sie besitzt
Sprachelemente mit meist natürlichen Begriffen aus der Anwendungsdomäne.
Das Gegenteil einer domänenspezifischen Sprache ist eine universell einsetzbare
Programmiersprache (engl. general purpose language, GPL), wie C und Java, oder
eine universell einsetzbare Modellierungssprache, wie UML.

Mit Hilfe einer solchen Sprache können ausschliesslich Problembeschreibungen
innerhalb des jeweiligen Problemgebiets beschrieben werden.
Andere Problembereiche sind ausgeblendet, damit der Domänenexperte sich
nur auf das für Ihn wichtigste, in dem jeweiligen Bereich, konzentrieren kann.

Der Domänenspezialist (z.B. ein Betriebswirt) ist mit dem Problembereich (z.B.
Produktpreisbildung) sehr vertraut. Die Domänensprache, z.B. zur Beschreibung
von Preisbildungskomponenten und deren Zusammenhänge gibt dem Betriebswirt ein
mögliches Werkzeug, um die Preise für Produkte (z.B. Computerhardware) dynamisch
anzupassen. Diese DSL ist dann aber für andere Bereiche, wie z.B.
der Aufstellung des Personalschichtplans nicht einsetzbar.

Die Charakteristik einer DSL ist vorzugsweise eine minimale Syntax, die nur
die nötigsten Mittel zur Strukturierung benötigt, um die Lesbarkeit zu erhöhen
und keine Ablenkung vom Problem zu schaffen. 
Was genau eine minimale Syntax ausmacht ist schwer zu messen.
Vorzugsweise sollte die Syntax keine Redundanzen aufweisen, wie das z.B. bei
XML der Fall ist, indem das offene und geschlossene Element den selben
Tagnamen tragen. Es sollte ein Zeichen bzw. eine minimale
Kombination aus mehreren Zeichen und deren Position in der DSL für eine Informationseinheit
verwendet werden.   Damit sind Zeichen gemeint, die auch eine angelehnte
Bedeutung zu der natürlichen Sprache haben, z.B. Klammern, Semikola, Kommas,
Punkte und Querstriche insbesondere auch Leerzeichen und
Zeilenumbrüche.

Fowler ist der begründeten Ansicht, dass zu einer DSL immer ein semantisches
Modell \cite[p. 159]{fowler2011domain} existieren sollte, das unabhängig von
der eigentlichen DSL ist, aber direkt dazugehört. Es ist das Modell zu der DSL 
oder auch ihr Schema. Die Anwendung der DSL instanziiert das semantische
Modell und ist damit eine gut lesbare Form der Modellinstanziierung. Das semantische Modell hat somit
große Ähnlichkeit mit einem Domänen Modell \cite[]{fowler2003patterns}.
Vorteilhaft ist damit die klare ``Trennung der Angelegenheiten'' (separation of
concerns) \cite{Huersch95separationof}, auf der einen Seite das Parsen der DSL
durch den Parser und auf der anderen Seite die daraus resultierenden Semantiken.
Die DSL ist damit eine Abbildung des Modells. Veränderungen können an diesem
formalen Modell separat zur DSL durchgeführt werden. Z.B. kann das semantische
Modell das von einer Zustandsmaschine sein, wie in Abbildung
\ref{state-machine-semantic-model} graphisch dargestellt.

 
\begin{figure}[h!]
	\begin{center}
	\includegraphics[width=0.7\textwidth]{pics/data-model.jpg}
	\end{center}
	\caption{Semantisches Modell einer 	Zustandsmaschine
	- neilvandyke.org/smores/ }
	\label{state-machine-semantic-model}
\end{figure}

\begin{figure}[h!]
	\begin{center}
	\includegraphics[width=0.7\textwidth]{pics/zutandsdiaGeldautomat.jpg}
	\end{center}
	\caption{Zustandsdiagramm Geldautomat
	\url{https://www.fbi.h-da.de/uploads/RTEmagicC_f2da95d8df.gif.gif} }
	\label{zutandsdiaGeldautomat.jpg}
\end{figure}

Z.B. ist das Metamodell von Zuständen eines Geldautomaten das Modell einer
Zustandsmaschine (Abb. \ref{state-machine-semantic-model}). Das Zustandsdiagramm
des Geldautomaten ist damit das in Abbildung \ref{zutandsdiaGeldautomat.jpg}
dargestellte. Es beschreibt alle Zustände und Zustandsübergänge bzw. deren
vorausgehende Ereignisse bzw. Aktionen. Eine DSL könnte dieses semantische
Modell, das Metamodell der Zustandsmaschine, mit den Gegebenheiten des
Geldautomaten instanziieren. (Code Listing \ref{geldautomat.dsl}).
   
\lstinputlisting[caption={DSL Ausschnitt für einen Geldautomat},
label={geldautomat.dsl},style=default]{code/geldautomat.dsl}
 


\subsection{Unterscheidungen}

Martin Fowler unterscheidet zwischen Ausprägungen von DSLs, indem er deren
Beziehung zu einer GPL benennt. Externe DSLs sind eigenständige und unabhängige
Sprachen, die einen eigenen, speziell angefertigten Parser besitzen. 

``Sowohl die konkrete Syntax als auch die Semantik können frei definiert
werden. SQL oder reguläre Ausdrücke sind Vertreter von externen DSLs.''
\cite{wikidsl} Wenn eine DSL innerhalb bzw.
mit einer GPL definiert wurde, nennt er diese interne DSL. Solche eingebettete
Spracherweiterungen sind mit den gegebenen Mitteln der ``Wirtssprache'',
genauer die Möglichkeit zur Metaprogrammierung (Kapitel
\ref{metaprogrammingLabel}), erstellt.
Vorzugsweise sind solche Wirtssprachen dynamisch typisiert wie z.B. Ruby, Groovy
oder Scala. 
``Dadurch sinkt der Implementierungsaufwand. Eine interne DSL ist immer eine echte
Untermenge einer generelleren Sprache.'' \cite{wikidsl}

DSLs, die nicht in der Hostsprache implementiert sind, werden von einer anderen
Programmiersprache geparst und weiterverarbeitet. Eine eigenständige
Sprachdefinition unterliegt keiner Einschränkung durch die Wirtssprache.
Damit sind absurde Szenarien gemeint, bei denen z.B. Methodennamen hinter die
Argumentenklammer geschrieben sind: ``(1,1)addiere'' oder sonstige denkbare
syntaktische Abwandlungen.


\subsection{Vergleich zu MDA / MDD } 


Model Driven Architecture (MDA) bzw. Model Driven Development (MDD) und Me-
taprogrammierung bzw. DSLs haben eine vergleichbare Problemstellung.
 

Mit der MDA richtet die OMG ihren Fokus nicht auf die Nutzung
von DSM-Sprachen, sondern auf generisches UML in graphischer Form,
ihre eigene Standard-Modellierungssprache.

Auch graphische Modelle müssen eine formale Sprache haben, damit sie weiter 
verarbeitet werden können.  Eine DSL ist eine textuelle Repräsentation des 
semantischen Modells.
 
Die Komplexität und das Abstraktionsniveau sind abhängig von dem verwendeten
semantischen Modell, nicht seiner Repräsentation. 

Eine DSL hat den Vorteil, dass ihre Darstellung simpler ist. Man kann sie
beispielsweise mit einem einfachen Text Editor bearbeiten oder mit trivialen
Mitteln ein ``diff’’ zweier Versionen erstellen (vgl.  \cite{cuadrado2007building}.
\cite{spinellis2008rational}, nach \cite{biekermetaprogrammierung}).

``Mit der MDA richtet die OMG ihren Fokus nicht auf die Nutzung
von DSM-Sprachen, sondern auf generisches UML, ihre
eigene Standard-Modellierungssprache. Sie versucht nicht, das
möglicherweise existierende Domänen-Fachwissen einer Firma
einzukapseln, sondern nimmt an, dass dieses Wissen nicht
vorhanden oder irrelevant ist. '' \cite{dsmUhrenArtikel}
 

\section{Interne DSLs mit Groovy}

Groovy wurde entworfen, um auf der JVM (Java Virtual Machine)
ausgeführt zu werden. Ruby, Python, Dylan und Smalltalk dienten als Inspiration
für die Entwickler von Groovy.

Eine Maxime für den Entwurf von Groovy war die hochgradige Kompatibilität zu
Java. Die Sprache ist auch syntaktisch stark an Java angelehnt. Wenn eine .java
Datei in eine .groovy Datei umbenannt wird, dann ist diese genau so ausführbar.
Groovy Klassen können auch von Java Klassen erben.

Groovy besitzt Eigenschaften, die sich besser als die von Java eignen, um eine
DSL zu entwerfen. Dazu zählt die wahlweise dynamische Typisierung, Closures,
native Syntax für Maps, Listen und Reguläre Ausdrücke, ein einfaches
Templatesystem, eine
XQuery-ähnliche Syntax zum Ablaufen von Objektbäumen, Operatorüberladung und
eine native Darstellung für BigDecimal und BigInteger.  

In den nächsten Abschnitten handelt diese Arbeit von den wichtigsten Features
dieser Programmiersprache, die sich für die Erstellung einer internen DSL
eignen. 


\subsection{Syntaxeigentschaften}

Bei ``top-level'' Ausdrücken wie z.B. \texttt{println(``x'')} ist es erlaubt,
die Klammern wegzulassen: \texttt{println ``x'' }
 
Wenn der letzte Parameter einer Methode eine Closure ist, dann kann die
Closure auch ausserhalb des Methodenaufrufs geschrieben werden:
``\texttt{list.each()\{ println it \}}''. Die Klammern können auch weggelassen
werden: ``\texttt{list.each \{ println it \}}''.  
  
Bei Klassenmethoden können bei deren Aufruf die
Klammern nicht weggelassen werden. Bei Zuweisungen ebenfalls nicht ``\texttt{def
x = methodenName y}''.
   
 
\section{Metaprogrammierung}\label{metaprogrammingLabel}

Mittels Metaprogrammierung ist ein Programmierer in der Lage Quelltext zur
Laufzeit zu ändern. Ein Meta-Objekt-Protokoll (MOP) stellt diese dafür
benötigten Mittel bereit.
 
 

\section{Die MOP Leistungsträger}
Das MOP besteht aus den Haupt-Leistungsträgern: ``Metaclass'',
``Kategorien'' und ``Expandos''.

\subsection{Expando}\label{expando}

Expandos sind dynamische Repräsentationen von Groovy-Beans (Java-Beans mit
einfacherer Syntax).
Wenn eine Variable von einem Expando angefragt wird und diese nicht existiert, dann wird
keine Exception geworfen sondern null zurückgegeben. Auch wenn eine Variable
belegt wird und noch nicht existiert, dann wird diese im Expando erzeugt.
Es ist auch möglich, eine Closure einer Klassenvariable zuzuweisen.
Diese ist dann genau wie eine Methode aufrufbar. Die Notation von einem
Expando ist ``def x = new Expando()''

\subsection{Kategorien}

Wenn eine Methode, einer bereits existierenden Klasse, zur Laufzeit hinzugefügt
werden soll, dann erfolgt das mittels ``Kategorien''.
Um eine Methode x zu der vorhandenen Klasse java.lang.Number hinzuzufügen, ist
das Erstellen einer neuen Klasse mit einer statischen Methode x erforderlich.
Das erste Argument der Methode ist eine Referenz auf die Instanz.
Angewendet wird dann eine Kategorieklasse durch die folgende Notation:
\texttt{use(KlasseMitStatischemX)\{zahl.x\}}


 \subsection{Metaclass}\label{Metaclass}
 
Jede Groovy Klasse implementiert die ``groovy.lang.GroovyObject''
 Schnittstelle.
Dadurch ist die Methode \texttt{getMetaClass} auf jedem Groovy-Objekt
vorhanden.
Die \texttt{MetaClass} Klasse wird dadurch referenziert.

%TODO der folgende satz klingt komisch... "ist kein ..." besser "besteht kein solches"...

Verwendeten Java-Klassen implementieren dieses Interface nicht. Die 
\texttt{MetaClass} wird den Klassen auch zugewiesen und in einer
\texttt{MetaClass}-Registrierung (Registry Muster \cite{fowler2003patterns})
verwaltet.
In der \texttt{MetaClass} werden alle Metainformationen der eigentlichen Klasse
verwaltet. Die \texttt{MetaClass} erlaubt es, nach dem Expando (Abschnitt
\ref{expando}) Prinzip, neue Klassenvariablen und Methoden einem Objekt
hinzuzufügen.
Javaklassen beschreiben das Verhalten zur Zeit der Übersetzung, Metaklassen
das zur Ausführungszeit.
Die Kardinaliät zwischen Objekt und Metaklasse ist immer 1:1.
%Die \texttt{MetaClass} implementiert die Methode \texttt{invokeMethod}
In Abbildung \ref{groovyMetaclassDiagram} sind die Beziehungen zw. Groovy
Metaklassen, Klassen und Instanzen dargestellt. 

\begin{figure}[h!]
	\begin{center}
	\includegraphics[width=0.8\textwidth]{pics/groovyMetaklassen}
	\end{center}
	\caption{Beziehung von Metaklassen, Klassen und Instanzen \cite{mpInGroovy})}
	\label{groovyMetaclassDiagram}
\end{figure}

\subsection{Closures}

Closures sind abgeschlossene Code-Abschnitte, die an sich einen eigenen
Datentyp darstellen. Closures werden von geschweiften Klammern abgegrenzt.
Innerhalb einer Closure sind Parameter bzw. Argumente vom Ausführungscode durch
einen Pfeil getrennt \texttt{->}. Parameter vor dem Pfeil sind durch Kommas
getrennt.
Closures besitzen das Keywort \texttt{this} aber auch noch \texttt{owner} und
\texttt{delegate}

\paragraph{owner}
Das Attribut Owner ist eine Referenz auf die Elternklasse. Diese Eigenschaft
kann nicht geändert werden. \texttt{Owner} ist in den meisten Fällen gleich der
Referenz von  \texttt{this}, außer wenn die umschließende Closure in einer
andern Closure liegt.
\paragraph{delegate}
Diese Eigenschaft ist genau wie die \texttt{owner} Eigenschaft zu verstehen,
jedoch mit dem bedeutenden Unterschied, dass dem \texttt{delegate} ein anderes
Objekt zugeordnet werden kann. Das ist mit der \texttt{owner} Eigenschaft nicht
möglich. So kann z.B. eine Closure einem fremden Objekt zugeordnet werden,
jedoch ist das Elternobjekt immer noch das in dem die Closure definiert wurde.
Mit der Neuzuweisung von \texttt{delegate} zum Fremdobjekt ist die
Elternreferenz veränderbar.

\subsection{ExpandoMetaClass}

Die Metaclass Eigenschaft aus Abschnitt \ref{Metaclass} ist ein Expando
(Abschnitt \ref{expando}).
Diese ExpandoMetaClass kann auch dazu verwendet werden um z.B. Methoden zu
überschreiben. Eine Statische Methode kann mittels folgendem Ausdruck hinzugefügt
oder überschrieben werden: \texttt{Klasse.metaClass.static.x = \{
Closure-Inhalt\}}. 
Methoden können auch überladen werden. Konstruktoren können hinzugefügt oder
überschrieben werden. 
  

 


 
\chapter{Implementierung einer DSL }

Im praktischen Teil soll beschrieben werden, wie eine interne DSL mit Hilfe der
Groovy-Metaprogrammierung erstellt wurde.

\section{Die fachliche Domäne}
Der fachliche Bereich im gesamten Kontext ist die Hotellerie. Diese
Arbeit betrachtet die betriebswirtschaftliche Unterdomäne
 und darin noch spezieller die tagesabhängige Preisbildung für Hotelzimmer.

\section{Vorgehen}
Nach der Zieldefinierung soll eine Bestandsaufnahme gemacht werden, um die
Rahmenbedingungen offenzulegen. Danach werden die
Vorüberlegungen zur Zielerreichung dargestellt und anschließend die
Implementierung der Lösung beschrieben. Daraus entstehen jeweils Unterziele, die
in den einzelenen Abschnitten näher beschrieben sind. 

\section{Zieldefinierung}
Das Ziel war es eine Sprache zu erstellen, die sich ausschließlich durch
Preisbestimmung für jeden möglichen Tag in der Zukunft bzw. für jedes Apartment
im Hotel definiert.

\section{Bestandsaufnahme}
 Das Hotel
``Schoenhouse Apartments'' besteht aus 50 Apartments in Berlin Mitte. Der
Geschäftsführer ist Dipl.-Ing. Immanuel Lutz (Domänenexperte). Dieser bestimmt
auch hauptsächlich die Preisbildung der Apartments. Weiterhin besitzt das Hotel ein in Java
geschriebenes Property-Management-System (PMS), das zur Verwaltung folgender
Hauptkomponenten dient: Zimmer-, Gäste-, Apartment-, Sonderleistungs- und
Preisverwaltung.
Derzeit wird ein neuartiges PMS erstellt, dass auf Groovy-und-Grails basiert.
 
 \section{Vorüberlegungen}

Die Vorüberlegung erfolgte ohne den Domänenexperten. Lediglich die Zustimmung
für das Experiment ``Textuelle-Preisberechnung'' war gegeben, da der
Domänenexperte nur wenig Zeit dafür preisgeben wollte. Die Vorüberlegungen
bestanden hauptsächlich aus der Grammatikstruktur und der Semantik. 

Die DSL soll die Geschäftslogik für die dynamische Bildung der Zimmerpreise
beschreiben. In einem Hotel sind die Preise abhängig von Faktoren wie
``Angebot und Nachfrage auf dem Markt'', Investitionskosten, Zimmerkategorie,
Nebenkosten, Rabattaktionen, Provisionen der Geschäftspartner für eine
Zimmervermittlung, Zeitraum und überschneidende Ereignisse in der Umgebung
\cite[S. 44]{hahn1993tourismuspsychologie}. Mit Ereignissen sind Veranstaltungen
oder Feiertage sowie Saisons gemeint, diese beeinflussen Angebot und Nachfragen Bewertungen, die
das Hotel auf Buchungsportalen bekommen hat, sind ebenfalls entscheidend für den Preis. Wenn
z.B. mehrere schlechte Bewertungen abgegeben wurden und darauf hin nur noch wenige
Gäste buchen, muss überlegt werden, ob das mit dem Preis zu regulieren ist.
Nicht zuletzt beeinflusst die Auslastung einer Zimmerkategorie oder die
Gesamtauslastung des Hotels den Zimmerpreis. Das bedeutet, wenn nur noch ein
Zimmer im Hotel verfügbar ist, dann kann es entsprechend teuer verkauft werden.
Die Auslastung, Ereignisse und die Tage bis zu den Ereignissen zusammen
kombiniert, beeinflussen den Preis weiter. Auch die aktuelle Liquidität des
Unternehmens kann Einfluss darauf haben. Der Zimmerpreis ist auch sensibel
gegenüber den Preisen der direkten Konkurrenz in der Umgebung. \\
Der Faktor Markt ist der wohl am schwersten zu determinierende, da er sich aus
vielen anderen Faktoren zusammensetzt. Dazu gehört z.B. die Beziehung zwischen
angebotenen und nachgefragten Hotelzimmern. Wenn die Auslastung steigt und die
Nachfrage gleich bleibt, dann resultiert das in steigende Preise.
Bei sozialen, kulturellen oder politischen Ereignissen weichen die Zimmerpreise
erheblich von der ``Rac-Rate'' (Grundpreisrate) ab.
Es stellt sich als schwierig heraus, alle Faktoren deterministisch zu
modellieren, da vor allem der subjektive Geschmack oder persönliche Motivationen
der potentiellen Gäste nur über statistische Werte berechenbar sind. Genau so
ist es mit der Faktorenauswahl bei ökonomischen bzw. volkswirtschaftlichen
Werten, um die Kaufkraft der internationalen Gäste zu bestimmen.
Formal kann mit diskreten Werten modelliert werden, die in direkter Beziehung zu
dem Hotel stehen. Indirekte Beziehungen werden hier aus den oben genannten
Gründen nicht betrachtet.

Der Geschäftsführer muss genau diese Preislogik für
sein Unternehmen individuell, unabhängig und zeitnah regeln können.

\section{Erstellung der DSL}\label{erstellungDSL}
Begonnen hat die Erstellung der DSL mit der Vorstellung, dass es im PMS einen
Textbereich gibt, in dem die DSL eingefügt und editiert werden kann.
Der Texteditor sollte mindestens ein ``Rich-Text-Editor'' sein, damit der
Domänenexperte den Text formatieren kann.
Unter dem Textbereich ist es notwenig, zwei Buttons bereitzustellen. Einen um
die DSL Live anzuwenden und einen um die DSL zu simulieren also zu testen.

Da das zukünftige PMS in Groovy und Grails erstellt wird und explizit Groovy viele
Möglichkeiten der Metaprogrammierung und der DSL-Erstellung hat, ist es
naheliegend, die Preislogik in einer internen DSL umzusetzen. 

Aus der Zieldefinition geht hervor, dass das Resultat der Preisberechnungslogik
eine Tabelle sein muss, die für jeden Tag und jeden Zimmertyp eine Gleitkommazahl als
Preis beinhaltet (Tabelle \ref{zielDefinition}).  

\begin{table}[htpb]
  \centering
  \begin{tabular}{| l | c | r |} 
 	\hline 
  	Datum & Zimmerkategorie & Tagespreis \\
  	\hline 
	1.1.2013 &  Zimmerkategorie1 &  95.00 \\
	1.1.2013 &  Zimmerkategorie2 &  105.00 \\
	2.1.2013 &  Zimmerkategorie1 &  95.00 \\
	2.1.2013 &  Zimmerkategorie2 &  105.00 \\
	3.1.2013 &  Zimmerkategorie1 &  95.00 \\
	3.1.2013 &  Zimmerkategorie2 &  105.00 \\
	\hline 
  	\end{tabular}  
 	\caption{Zielstruktur}
  \label{zielDefinition}
\end{table}	 

Perspektivisch war der Gedanke, dass man von einer Menge alle Elemente dazu
benutzen muss, um den Preis zu bilden. Damit ist gemeint, dass sich die Tage in
einer Menge befinden und auch die Zimmerkategorien Mengenbasierend sind.
Weiterhin besteht die Berechnungslogik zum größten Teil aus mathematischen
Ausdrücken bzw. Formeln.
Bemerkenswert ist, dass die Erstellung der Domänenlogik nicht zuerst auf der
Grundlage des semantischen Modells erstellt wurde, sondern rein intuitiv auf
Basis von bekanntem Domänenwissen. Da sich das semantische Modell als das einer
Bash-Script-Sequenz mit Schleifen herausstellte, ist es nicht verwunderlich,
dass ein Programmierer mit langjähriger Erfahrung dies auch ohne Schema erstellen
konnte.
Begonnen wurde mit einem TestTreiber, der eine Textdatei einliest und diese
interpretiert bzw. evaluiert.
Cliff James hat das in einem
Tutorial\footnote{http://www.nextinstruction.com/blog/2012/01/08/creating-dsls-with-groovy/}
bewerkstelligt und folgenden Trick angewendet:
Die DSL befindet sich innerhalb einer separaten Datei und ist nach Ausführung
des Einlesecodes in einen interpolierten String umgewandelt. Anschließend wird
dieser String in einen Closure-Block eingefügt.
Da dieser eingefügte String, innerhalb einer ``run'' Methode liegt, ist der
Aufruf immer derselbe.
Die DSL wird letztendlich von der Groovy Shell Instanz evaluiert (\cite[S.
368]{koenig2007groovy}).
Doch ohne den Kontext, in dem die DSL ``ausgeführt'' werden soll, ist die DSL
nutzlos. Daher wird eine Instanz von Binding (\cite[S. 368]{koenig2007groovy})
dazu benutzt, um vordefinierte Variablen an das Script zu übergeben.
Z.B. um der Variable \texttt{run} eine Closure
zuzuweisen, die die loadDSL Methode im Runner aufruft wie im Code Listing
\ref{dslrunner.groovy}).
 

  Die Binding Instanz wird dann an die GroovyShell
Instanz übergeben, um die Assoziationen zu gewährleisten.

Mit Groovy-Metaprogrammierung ist es möglich, den Kontext von einer in eine adere Instanz zu
wechseln. \texttt{Delegate} wechselt also zu
\texttt{this} und damit ist dann die DSL Bestandteil des DSLRunners. Das
bedeutet, dass alles was in der DSL-Datei geschrieben wurde jetzt Methoden und
Variablen der DSLRunner-Klasse referenzieren kann.
 
\lstinputlisting[caption={DSL-Runner},
label={dslrunner.groovy},style=default]{code/dslrunner.groovy}

Da nun jedmögliche Textdatei an den DSLRunner übergeben werden konnte, um
Groovy-Script-Code auszuführen, ist es dementsprechend auch möglich, den Inhalt
des besagten Textfeldes als Input zu benutzen. Diese Implementierung
wurde übersprungen, da die DSL durch testgetriebene Verfahren
\cite{beck2002driven} direkt in der IDE\footnote{www.jetbrains.com/idea/ }
ausgeführt werden kann.
 Eine Schleifeniteration besteht aus einer Liste oder
einem Abschnitt (Range), gefolgt von der \texttt{each} Methode und der
auszuführenden Closure als Parameter dafür. Siehe Code Listing \ref{normalGroovyLoop.goovy}. 

\lstinputlisting[caption={Orgniale Groovy Schleifenbeispiel
http://groovy.codehaus.org/Collections}, label={normalGroovyLoop.goovy},style=default]{code/normalGroovyLoop.goovy}

Die Versionkontrollhistorie zeigt, dass der erste Eintrag in der DSL aus einer
Schleife über einem Zeitraum von zwei Jahren erstellt wurde, denn eine finale
Liste kann nur durch eine schleifenähnliche Funktion erstellt werden
\ref{firstDSLEntry.groovy}.

\lstinputlisting[caption={erster DSL Enturf},
label={firstDSLEntry.groovy},style=default]{code/firstDSLEntry.groovy}

Durch die im theoretischen Teil vorgestellten Kategorien war es nun möglich,
anstatt der speziellen Notation für zwei Jahre, bzw. die Instanziierung einer
Dauer (Duration), die Notation \texttt{2.years} zu verwenden. 

Weiterhin wurde die Instanz
der \texttt{ExpandoMetaClass} der Date-Klasse (Date.metaClass) dazu verwendet,
um eine Methode namens ``bis'' für die Date-Klasse zu definieren, die wieder ein Date
Objekt als Argument entgegennimmt und daraus einen (Zeit)Abschnitt (engl.
Range, Notation: \texttt{(start..stop)}  ) ableitet.

Durch das Binding Objekt konnte die vordefinierte Instanz (\texttt{new Date()}) mit dem
Variablennamen \texttt{heute} übergeben werden. Diese Variable konnte somit in
der DSL als solche verwendet werden. 

Die erste Spalte der Zieltabelle ist somit darstellbar, aber die Lesbarkeit war
erheblich durch Sonderzeichen beeinträchtigt. Ziel war nun die Lesbarkeit zu steigern, indem Sonderzeichen weitestgehend eliminiert werden und
englische Begriffe durch deutsche ersetzen werden.
Zuerst wurde das Wort \texttt{each} durch \texttt{alle} ersetzt. Hier wurde das
ExpandoMetaObject dafür benutzt, um der Überklasse ``java.util.Collection'' eine
Closure für die neu definierte Eigenschaft \texttt{alle} zu übergeben. Die
Closure sollte nun eine Iteration über alle Elemente in der Menge leisten und dabei
nochmals eine Closure entgegennehmen, in der dann die Operation auf das Element
definiert wird. Ausserdem muss der Deligierte wieder auf die Mengeninstanz
gewechselt werden. Abbildung \ref{alle.groovy} zeigt den Codeabschnitt im
DSLRunner.

\lstinputlisting[caption={Definition von [1,2].alle(\{..\})},
label={alle.groovy},style=default]{code/alle.groovy}

Weiterhin wurde aus \texttt{2.years} eine neue Kategorie definiert, die die
deutsche Bezeichnung von Jahren benutzt. Also \texttt{2.jahre} oder
\texttt{1.jahr}.
Dazu wurde das metaClass ExpandoMetaObject von der Klasse Number
dahingehend verändert, dass solche Konstruktionen möglich werden (Code Listing
 \ref{jahre.groovy}).

\lstinputlisting[caption={Expando Metaclass Jahre},
label={jahre.groovy},style=default]{code/jahre.groovy}

Durch die vorgestellten Syntaxeigenschaften ist es möglich die Klammern
wegzulassen und damit den in Code Listing \ref{finalIterationCode.groovy}
dargestellten DSL-Code zu erzeugen.

\lstinputlisting[caption={Iterationsnotation auf Basis von Kategorien},
label={finalIterationCode.groovy},style=default]{code/finalIterationCode.groovy}

Um diesen gut lesbaren Code an die deutsche Ausdrucksweise anzulehnen,
ist die Verwendung von Command Expressions hilfreich, um eine Fluent
Intercace \cite{fowler2005fluent} DSL zu erstellen. Das bedeutet, dass in der
deutschen Sprache eigentlich folgender Ausdruck der natürlichste wäre: ``alle
Tage von heute bis in zwei Jahren einzeln auflisten und jeden Tag immer als Tag
bezeichnen.'' Diese umständliche Ausdrucksweise ist zwar präzise, enthält aber
gegenüber einer mit minimalen Sonderzeichen geschriebenen Notation noch zu viele Begriffe.
Ein valider Kompromiss ist folgender: ``von heute bis 2.jahre alleTage \{ tag
-> \ldots\}''.
Dieser Kompromiss wurde ausgehend von der vorhandenen Programmiersprache, in der
die DSL ``eingebettet'' sein soll, und der subjektiven Empfindungsweise des
Autors gemacht. 
Die Präposition ``von'' ist der Name einer Methode, die als Argument ein Datum
akzeptiert und eine Methode als Rückgabewert hat.
``Von'' ist somit eine Methode höherer
Ordnung\footnote{ \url{de.wikipedia.org/wiki/Funktion_höherer_Ordnung} } und
in Code Listing \ref{fluentInterface.groovy} dargestellt.

\lstinputlisting[caption={Fluent Interface Implementierung},
label={fluentInterface.groovy},style=default]{code/fluentInterface.groovy}

Der Rückgabetyp ist eine HashMap mit ``keys'' als Methodennamen und Closures als
``values'' bzw. dazugehörige ``Methodenkörper''.
Wenn genau das der Fall ist, ist so ein Listeneintrag wiederum ein Objekt, an
dem Methoden aufgerufen werden können. Wenn eine Map zurückgegeben wird, dann
identifiziert sich der Eintrag der Map anhand des Schlüssels (\texttt{bis}).
\texttt{Bis} referenziert somit einen Closurekörper, der ein Argument entgegennimmt,
welches vom Typ \texttt{Date} ist. Letztendlich gibt diese Closure eine Instanz
von \texttt{Range} zurück. Der Vorteil dabei ist, dass das Argument vom ersten
Methodenaufruf (\texttt{von(datum)}) in der Closure des zweiten Methodenaufrufs
benutzt werden kann und somit dieses ``Fluent Interface'' eine abgekapselte
Einheit darstellt.
Daraus ergibt sich nun folgende neue Notation für die DSL (Code Listing
\ref{finaldateRangeDSL.groovy}).
Durch triviales Kopieren der \texttt{alle} zu \texttt{alleTage} ExpandoMetaObjekt
Instanz wurde nach dem DRY Prinzip\footnote{Dave Thomas, interviewed by Bill Venners
(2003-10-10) http://www.artima.com/intv/dry.html} die Closure
wiederverwendet und \texttt{alleTag}e steht für eine Menge, genauer für eine
ObjectRange zur Verfügung.

\lstinputlisting[caption={Fluent Interface Anwendung},
label={finaldateRangeDSL.groovy},style=default]{code/finaldateRangeDSL.groovy}
 
Wie in der Vorbetrachung angemerkt, beziehen sich die Preise nicht nur auf den
Zeitraum, sondern auch auf die jeweilige Zimmerkategorie.
Die Information aus der Hostdomäne (Abb. \ref{domainModelDia.png}) bzw. aller
Zimmerkategorien, muss nun in Verbindung mit der DSL gebracht werden.

 
\begin{figure}[h!]
	\begin{center}
	\includegraphics[width=1.3\textwidth,angle=90]{pics/domainModelDia.png}
	\end{center}
	\caption{PMS - Domänen Modell Diagrammausschnitt}
	\label{domainModelDia.png}
\end{figure}

Bestenfalls sollte folgende Semantik nützlich sein:
\texttt{Hotel.Zimmerkategorien}, um die Menge abzubilden.
Das Binding Objekt erlaubt nun, eine Referenzierung der Domänenmodellinstanzen
mittels dem Grails Framework. Problematisch ist die unterschiedliche Benennung
der DSL Notation und der Domänenmodelle. Beispielsweise heisst das Hotel im
Domänenmodell \texttt{Estate} und in der DSL nur \texttt{Hotel}. Wiederum
heissen die Zimmerkategorien nicht so, sondern \texttt{EstateRoomType}. Es ist
notwendig ein Mapping zu erstellen, das genau diese Fälle abdeckt. Der Binding
Schlüsselwert für das Estate Objekt ist dann \texttt{Hotel}.
Da aber die Zimmerkategorien auf kein Feld innerhalb des Domänenmodells
referenziert sind, muss ein erneutes Mapping erfolgen. Trivial wäre es in dem
Domänenobjekt eine Kopie auf \texttt{estateRoomTypes} zu machen. Da aber so
keine Kapselung erreichen wird ist es notwendig ein Wrapper-Objekt
(Adapter-Muster)
 \cite{gamma1995design} zu erstellen und das an die DSL zu binden (Code Listing
 \ref{EstateDSLWrapper.groovy}).
 
\lstinputlisting[caption={EstateDSLWrapper.groovy},
label={EstateDSLWrapper.groovy},style=default]{code/EstateDSLWrapper.groovy}

Das Binding ist in Listing \ref{estateBinding.groovy} dargestellt.

\lstinputlisting[caption={estateBinding.groovy},
label={estateBinding.groovy},style=default]{code/estateBinding.groovy}

Analog dazu ist dieses Vorgehen auch mit den definierten Ereignissen
``PriceVariationRange'' durchführbar, welche aus dem Domänenmodell an die DSL
gebunden werden. Da eine Iterationsnotation (``alle'') eingeführt wurde, ist es nun insgesamt möglich, {\bf Schleife}n zu schachteln Code Listing
\ref{multipleLoops.dsl}.
 
\lstinputlisting[caption={multipleLoops.dsl},
label={multipleLoops.dsl},style=default]{code/multipleLoops.dsl}

In Code Listing \ref{multipleLoops.dsl} ist zusätzlich auch schon der erste
{\bf Ausdruck} in Zeile 4 dargestellt. Es handelt sich um
eine Variablendefinition inklusive {\bf Zuweisung}. Dieser greift auf
die Iterationsvariable \texttt{ZimmerTyp} zu und referenziert die in dem Wrapper
festgelegte Eigenschaft Grundpreis. Im DomänenModell \texttt{Estate} heisst diese
Klassenvariable \texttt{racRate}.
Die {\bf Variable} \texttt{Tagespreis} ist letztendlich die, die modifiziert und anschließend in der Ergebnistabelle dem Tag und der
Kategorie zugewiesen werden soll. Die Endtabelle soll in Form einer Liste
definiert werden, um dann mit dem Listenoperator ( << ) diese
zu füllen. Die Listennotation ist trivialerweise folgende: ``listenname = []''.

Bisher wurden alle Informationen beschrieben, um eine finale Implementierung
durchzuführen. Code Listing \ref{trivialSolution.groovy} zeigt, dass die
Zielstellung dahingehend erreicht ist, dass eine Liste wie in Tabelle
\ref{zielDefinition} durch die DSL berechnet wird.
 
\lstinputlisting[caption={Triviale Lösung des Problems},
label={trivialSolution.groovy},style=default]{code/trivialSolution.groovy}

Das Resultat kann automatisch und transparent gegenüber dem Domänenexperten
durch ein XML oder JSON Mapping an die ``PartnerChannels'' (Booking.com oder HRS) geschickt werden.
Das zu Implementieren ist nicht Bestandteil dieser Arbeit.

Da das Grundgerüst der DSL damit geschaffen ist, erfolgt nun die Anpassung des
Tagespreises durch {\bf Formel}n und {\bf Bedingung}en.

Da der Domänenexperte höchstwahrscheinlich mit Prozenten arbeiten will, sollte
es für denjenigen möglich sein, diese Zahlen{\bf funktion} einfach benutzen zu
können. Mit Hilfe von Kategorien ist es möglich das zu bewerkstelligen, um
letztendlich folgendes DSL
Wort\footnote{http://de.wikipedia.org/wiki/Wort\_\(Theoretische_Informatik\)}
zu erstellen: ``10 prozent Tagespreis''. Die Kategorie dazu ist in Code Listing
\ref{EnhancedNumber.groovy} dargestellt.
 
\lstinputlisting[caption={Kategoriedefinition für Prozent},
label={EnhancedNumber.groovy},style=default]{code/EnhancedNumber.groovy}

Wie in der Vorüberlegung schon angedeutet, gibt es z.B. eine Preiserhöhung, wenn
ein bestimmtes Ereignis eingetroffen ist. Ein wiederkehrendes
Ereignis ist z.B. ein Wochenende. Wenn sich also der Domänenexperte dazu
entscheidet den Preis am Wochenende um 10\% anzuheben, sollte er folgendes in der
DSL schreiben können: ``wochenendaufschlag = wenn tag.wochenende dann 10 prozent
tagesPreis''. Wie
bei der Zeitabschnittbestimmung (von(x).bis(y)) wurde hier wieder die Methode
eines Fluent Interfaces benutzt (Code Listing
\ref{ifelseCase.groovy}).
 
\lstinputlisting[caption={DSL - if else Ausdruck},
label={ifelseCase.groovy},style=default]{code/ifelseCase.groovy}

Diese Wenn-Dann-Kombination ist wie an der 0 zu erkennen, nur für Formeln
einsetzbar. 
Alle zusätzlichen Erweiterungen für die Date-Klasse sind in Code Listing
\ref{completeDateMetaClass.groovy} dargestellt. Darunter befindet sich auch die
Erweiterung ``getWochenende bzw. wochenende''.

\lstinputlisting[caption={Erweiterungen für die Date-Klasse},
label={completeDateMetaClass.groovy},style=default]{code/completeDateMetaClass.groovy}
 
Dem Domänenexperten wird nun unterstellt, dass er x += 1 als Summierung für x =
x + 1 erlernen kann. Letztendlich wäre er nun in der Lage folgenden Ausdruck zu
schreiben: ``TagesPreis += wenn Tag.wochenende dann 10 prozent TagesPreis''.
 
Weiter könnte sich der Hotelbetreiber dazu entscheiden, folgende Modifikation an
dem Tagespreis durchzuführen: Je nach dem wie das Hotel prozentual ausgelastet
ist, wird der Tagespreis um diesen prozentualen Anteil von einem Drittel des
Grundpreises erhöht oder verringert.
Wieder durch die Binding-Möglichkeit können weitere vordefinierte Variablen
übergeben werden. Z.B. ``binding.gesamtzimmer =
Estate.estateRoomTypes*.count()'' und weiterhin die Anzahl der freien
Zimmer als Methode (Code Listing \ref{predefinedVars.groovy}).

\lstinputlisting[caption={Vordefinierte Variablen},
label={predefinedVars.groovy},style=default]{code/predefinedVars.groovy}
 
Abschließend soll hier noch weiter die Möglichkeit vorgestellt werden, wie auf
die vorher erwähnten bzw. vordefinierten Ereignisse zugegriffen werden kann, um
eine Tagespreis-Manipulation durchzuführen.
Code Listing \ref{finalDSLComplete.dsl} zeigt eine mögliche Form der DSL, in der
ca. 90\% der Konzepte beispielhaft dargestellt sind.  

\lstinputlisting[caption={DSL Beispiel},
label={finalDSLComplete.dsl},style=default]{code/finalDSLComplete.dsl}
 
Dabei sei nochmals auf folgende besondere Konstruktion hingewiesen: \texttt{tage
von:
heute, bis: ereignis.start} (Ziele 15). Das ist eine spezielle Notation in
Groovy Namens ``named parameters''. \texttt{tage} ist eine Methode, die zwei
Parameter entgegennimmt.
\texttt{von} und \texttt{bis}, die auch so benannt werden müssen. Durch das
Entfernen der Klammern ist jetzt die dahinterliegende Struktur zu erkennen. Die
Alternative hinter dem Ausdruck im Kommentar (Zeile 15) ist anders aufgebaut.
\texttt{abstand} ist eine Methode, die eine Closure als Argument entgegennimmt,
in diesem Fall einen Abschnitt (Range).

\section{Das semantische Modell}

Im Kapitel \ref{erstellungDSL} wurde beschrieben wie die DSL erstellt wurde.
Dabei wurden einige Begriffe mit bold markiert, um die wichtigsten
Meta-Bestandteile zu verdeutlichen. In Abbildung \ref{mm.png}
ist deren Zusammensetzung bzw. das semantische Modell der Preisberechnung
dargestellt.
Dieses ist sehr stark an das einer Skriptsprache angelehnt.
In diesem Modell sind nur Berechnungsbestandteile durch Ausdrücke und Schleifen
definiert. In einer Scriptsprache ist darüber hinaus noch mehr möglich.
 
\begin{figure}[h!]
	\begin{center}
	\includegraphics[width=0.99\textwidth]{pics/mm}
	\end{center}
	\caption{Preisberechnung semantisches Modell}
	\label{mm.png}
\end{figure}

Die Erstellung dieses Modells, wurde nach der Erstellung der DSL gefertigt, um
daraus z.B. eine bessere Dokumentation zu erstellen, die dem Domänenexperten
hilft die DSL zu erstellen.
  
In Abbildung \ref{mmInstanz.png} ist ein Instanzdiagramm, der ersten DSL
Zeilen von Code Listing \ref{finalDSLComplete.dsl}, um das semantische Modell zu
verifizieren.
Durch die Codezeilen-Eigenschaft eines Berechnungsbestandteils kann die
Abarbeitungssequenz dargestellt werden. Die drei Schleifen werden abgebildet und
die einzelnen Ausdrücke innerhalb der Schleifen, wie z.B. \texttt{wenn
TagInnerhalbEreignis dann 10 prozent tagesPreis} oder\\ \texttt{Tagespreis =
Zimmertyp.Grundpreis}. Die grau markierten Instanzen sollen farblich darstellen,
dass es sich um ein und dasselbe handelt. 

\begin{figure}[h!]
	\begin{center}
	\includegraphics[width=0.99\textwidth]{pics/mmInstanz}
	\end{center}
	\caption{Instanzdiagramm der ersten Codezeilen}
	\label{mmInstanz.png}
\end{figure}
 \clearpage
 
\chapter{Einbezug der Domänenexperten}

Die Vorstellung der DSL ist hier in einem Interviewmitschnitt\footnote{51 min -
http://srvme.de/mda/mitschnitt.mp3} aufgezeichnet worden.


\section{Aufgaben zur DSL für den Domänenexperten}

Der Entwurf der DSL wurde dem Domänenexperten vorgestellt und es wurden
Aufgaben bezüglich der in Code Listing \ref{finalDSLComplete.dsl} gezeigten DSL gemacht.
Die Aufgaben sind:

\begin{itemize} 
\item Erhöhen sie den Grundpreis aller Kategorien um 10 Euro. 
\item Der Zeitraum soll anstatt von heute von morgen beginnen.
\item Die Ereignisse sollen bei der Berechnung keine Rolle mehr spielen.
\item Die Gesamtzimmeranzahl ist um eins gestiegen.
\item Der Lastminuterabatt soll in Lastminutezuschlag umgewandelt werden.
\item Definieren sie neu: ExtraLastminuterabatt bei dem 5 Tage vorher
das Zimmer 20 Euro weniger kosten soll. 
\item Die Liste soll mit einem Tabellenkopf versehen werden, der die
Spaltenbezeichung beinhaltet: ``Kategorie'', ``Datum'', ``Tagespreis''. 
\end{itemize}

\section{Lösungen zu den Aufgaben}

Einer anderen Domänenexpertin, ohne betriebswirtschaftlichen Hintergrund und
viel Erfahrung im Umgang mit Excel, wurde die vorhandene DSL (Code Listing
\ref{finalDSLComplete.dsl}) gezeigt und erklärt.
Dabei sollten die Fragen beantwortet werden. Die Expertin war nur mit Hilfe dazu
in der Lage, die Fragen zu beantworten.
Die Befragung fand im Büro ohne jegliche Störungen statt. Der Expertin wurde die
Preislogik-DSL vorgestellt und es wurden Erläuterungen zum Denkprozess bei der
Erstellung der DSL kommuniziert (ca. 20 Minuten). 20 Minuten wurden für die
Aufgabenlösung und 2 Minuten zur Auswertung verwendet. Durch die Abwesenheit
einer Legende wurde der Lösungsweg weiterhin erschwert. Die DSL wurde ohne
Syntaxhighlighting auf dem Bildschirm repräsentiert. Die Benutzung
der DSL musste sich die Expertin als ein Gedankenexperiment
vorstellen.
Eine Aufzeichnung\footnote{42 min - http://srvme.de/mda/aufgabenloesung.mp3} von dem Interview schildert die Aufgabenlösung.


  
\chapter{Auswertung}
  

\section{Beurteilung durch Domänenexperte}\label{reaktionExperte}

Die Idee eine DSL einzuführen wurde überwiegend positiv aufgenommen, weil
denkbar jede elektronische Unterstützung für die Domäne zuallererst als
hilfreich bewertet wird.
In dem vorhandenen PMS hat die Domänenexpertin keinen direkten Kontakt mit der
Preislogik, sondern nur indirekt.
Unsicherheit entstand, als die Domänenexpertin die DSL zur Preisberechnung
 zum ersten Mal gesehen hat, weil sie an eine
rein textuelle Repräsentation nicht gewohnt ist. Die Wahrnehmung
und die Erkennung der Bestandteile wurde erst bei näherem Betrachten klarer. 
Die Expertin war der Meinung, dass eine bessere visuelle Repräsentation der
Unterscheidung helfen würde. Abschließend wurde die DSL als ein geeignetes
Kommunikationsmedium gutgeheißen, da die Kommunikation mit dem Programmierer nicht immer eindeutig ist.
Gegenüber einer grafischen Benutzeroberfläche wurde die DSL und deren Notation
als ``verwirrend'' eingestuft. Jedoch wurde die DSL letztendlich als flexibler
angesehen, da eigene Variablendefinitionen in vordefinierten, grafischen User Interfaces eher unüblich sind.
Positiv sind die überwiegend richtigen Antworten der Fragen zu bewerten.
Insgesamt wurden mit Hilfestellung 80\% der Fragen beantwortet. Die Fragen waren
aufgrund ihrer Nachfragen nur zu 80\% eineindeutig.

%Bewertung des Probands: Lesbarkeit, intuitivem Verständnis und Flexibilität


\section{Beurteilung durch Programmierer}\label{reaktionProgrammierer}
 
Die Einsparung des GUI-Interfaces ist gegenüber der Entwicklungsgeschwindigkeit
als positiv zu bewerten, wenn die DSL als Kommunikationsmedium mit dem Experten
benutzt werden soll. 
Da die DSL über keinen speziellen Editor verfügt, der direkte Hilfe für die
Erstellung der DSL bietet (Syntax Fehler, Autovervollständigung, Debugger,
Versionskontrolle), ist ein fehlerfreies und effektives Editieren fast unmöglich
und würde beim Domänenexperten schnell zu Frustration führen. 

Die Möglichkeiten zur Erstellung einer DSL in Groovy sind ausreichend, aber oft
in der Notation beschränkt. 
Die Implementierung einer eigenen DSL war für den Programmierer ein neues
Gebiet. Der Aufwand zum Erlernen der DSL-Leistungsträger in Groovy war gegenüber
einer herkömmlichen statischen Implementierung hoch. Die Benutzung des MOP ist ein
erheblicher Gewinn gegenüber den herkömmlichen Programmiermethoden, da nach
einer Implementierung ausdrucksstärkerer Quelltext vorliegt, der die Lesbarkeit
fördert.
Eine zukünftige Verwendung von DSLs und dem MOP ist nach dieser Arbeit für den
Autor fast nicht mehr wegzudenken, da der Nutzen den Aufwand beim 
Erstellen deutlich überwiegt. Lediglich beim Lernen der Konzepte gab es
einen deutlichen Mehraufwand. 
 
\section{Zusammenfassung und Ausblick}

Sprachorientierte Programmierung wurde in dieser Arbeit betrachtet. Als
Mittel für die Erstellung einer DSL wurde die Groovy-MOP verwendet, weil die
Wirtssprache des PMS auch Groovy ist. Die erstellte DSL
diente als Bewertungsgrundlage dieses Paradigmas aus der Sicht des
Programmierers und aus der des Domänenexperten. 
In zukünftigen Arbeiten ist die Verwendung von geeigneten Editoren für DSLs 
unvermeidbar, um das Paradigma Sprachorientierte Programmierung noch besser
anwendbar zu machen.  ``Language Workbenches'' bieten eine vielversprechende
Lösung (\cite{10.1109/MS.2011.139}, \cite{fowler2005language}
 \cite{dmitriev2004}, \cite{fowler2011domain}).
    
\bibliographystyle{alphadin}
\clearpage\addcontentsline{toc}{chapter}{\bibname}\bibliography{jabref}
\appendix
\renewcommand{\theequation}{A-\arabic{equation}}

\setcounter{equation}{0}  % reset counter \chapter*{Anhang}  % use *-form to

%\chapter{Anhang}
\addcontentsline{toc}{chapter}{Anhang}

%\section{Anhang A - Screenshots}\label{appendixA}


%\listoffigures
\end{document}