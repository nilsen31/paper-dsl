

\documentclass[11pt,english,ngerman, headsepline]{scrreprt}
\usepackage{lmodern}
\renewcommand{\sfdefault}{lmss}
\renewcommand{\ttdefault}{lmtt}
\usepackage[T1]{fontenc}

\usepackage{listings}

\usepackage[utf8]{inputenc} \usepackage[a4paper]{geometry}
\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=3cm,rmargin=2.75cm,headheight=1cm,headsep=0.666cm,footskip=1cm}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{babel}
  \usepackage{tipa}
\usepackage{verbatim} 
\usepackage{float}  
\usepackage{courier}
\usepackage{url}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage[square,sort,numbers]{natbib} \usepackage[utf8]{inputenc}
\usepackage{graphicx} 
\usepackage[xindy,toc]{glossaries}
 
 
 
\input{formating/formating.tex}

\parindent 0pt

\begin{document} 


\input{deckblatt/deckblatt.tex}

\selectlanguage{ngerman}%
\tableofcontents{}

\pagestyle{scrheadings}    %Kopfzeile ein


% ==========================================================================
% DOCUMENT START
% ==========================================================================

\chapter{Einleitung} 

Die Sektionen würden bei der echten Arbeit wegfallen.

\section{Motivation (Heranführen an das Thema)}

Das Wort “Abstraktion” bezeichnet meist den induktiven Denkprozess des
Weglassens von Einzelheiten und des Überführens auf etwas Allgemeineres oder
Einfacheres [...] alsö[...] jenen Prozess, der Informationen söweit auf ihre
wesentlichen Eigenschaften herab setzt, dass sie psychisch überhaupt weiter
verarbeitet werden können. (nach \cite{wikiAbsraktion}) Die grundlegenden
Abstraktionsstufen in der Informatik sind wie folgt aufgeteilt: Die unterste
Ebene ohne Abstraktion ist die der elektronischen Schaltkreise, die elektrische
Signale erzeugen, kombinieren und speichern. Darauf aufbauend existiert die
Schaltungslogik. Die dritte Abstraktionsschicht ist die der Rechnerarchitektur.
Danach kommt eine der obersten Abstraktionsschichten: “Die Sicht des
Programmierers”, der den Rechner nur noch als Gerät ansieht, das Daten speichert
und Befehle ausführt, dessen technischen Aufbau er aber nicht mehr im Einzelnen
zu berücksichtigen braucht. (nach S. 67 \cite{rechenberg2000informatik}). Diese
Beschreibung von Abstraktion lässt sich auch auf Programmiersprachen übertragen.
Nur wenige programmieren heute direkt Maschinencode, weil die
Programmiersprachen der dritten Generation (3GL) soviel Abstraktionsgrad bieten,
dass zwar kein bestimmtes Problem aber dessen Lösung beschrieben werden kann.
Die Lösung des Problems muss genau in der Sprache beschrieben werden und setzt
das Verständnis und die Erfahrung in der Programmiersprache und deren
Eigenheiten zur Problemlösung voraus. Das Verständnis des eigentlichen Problems,
dass es mit Hilfe von Software zu lösen gilt, liegt nicht immer zu 100\% bei dem
Programmierer, der es mit Java oder C\# bzw. einer 3GL lösen soll. Komplexe
Probleme z.B. in der Medizin, der Architektur oder im Versicherungswesen sind
oft söumfangreich, dass die Aufgabe des “Requirements Engeneering”
hauptsächlich darin besteht, zwischen dem Auftragnehmer und Auftraggeber eine
Verständnisbrücke zu bauen. Diese Brücke ist auf der einen Seite mit
Implementierungsdetails belastet und auf der anderen mit domänenspezifischem
Wissen (Fach- oder Expertenwissen). Die Kommunikation der beiden Seiten kann
langfristig durch eine DSL begünstigt werden, da eine Abstrahierung des
domänenspezifischen Problems angestrebt wird. Die Isolation der eigentlichen
Businesslogik und eine intuitiv verständliche Darstellung in textueller Form
kann sogar soweit gehen, dass der Domänenexperte die Logik in hohem Maße selbst
implementieren kann, weil er nicht mit den Implementierungsdetails derselben und
den syntaktischen Gegebenheiten einer turingvollständigen
General-Purpose-Language wie Java oder C\# abgelenkt wird. Im Idealfall kann er
die gewünschten Anforderungen besser abbilden.(vlg. \cite{heiseMPS2}). Beispiele
für DSL sind z.B.: Musiknoten auf einem Notenblatt, Morsecode oder
Schachfigurbewegungen (“Bauer e2-e4”) bis hin zu folgendem Satz: “wenn (Kunde
Vorzugsstatus hat) und (Bestellung Anzahl ist größer als 1000 oder Bestellung
ist neu) dann ... ”. “Eine domänenspezifische Sprache ist nichts anderes als
eine Programmiersprache für eine Domäne. Sie besteht im Kern aus einem
Metamodell einer abstrakten Syntax, Constraints (Statischer Semantik) und einer
konkreten Syntax. Eine festgelegte Semantik weist den Sprachelementen eine
Bedeutung zu.” (vlg. S.30 \cite{mdaDPunkt}). 

\section{Begriffserklärung}
Eine DSL beinhaltet ein Metamodell. In einer Domänengrammatik gibt es das
Konzept an sich, das beschrieben werden soll. Konzepte können Daten, Strukturen
oder Anweisungen bzw. Verhalten und Bedingungen sein. Das Metamodell oder auch
das Semantische Modell besteht aus einem Netzwerk vieler Konzepte. Das Paradigma
“Language Orientated Programming” (LOP) identifiziert ein Vorgehen in der
Programmierung, bei dem ein Problem nicht mit einer GPL (general purpose
language) angegangen wird, sondern bei dem zuerst domänenspezifische Sprachen
entworfen werden, um dann durch diese das Problem zu lösen. Zu diesem Paradigma
gehört auch die Entwicklung von domänenorientierten Sprachen und intuitive
Programmierung (intentional programming). “Intentional Programmierung ist ein
Programmierparadigma. Sie bezeichnet den Ansatz, vom herkömmlichen Quelltext als
alleinige Spezifikation eines Programms abzurücken, um die Intentionen des
Programmierers durch eine Vielfalt von jeweils geeigneten
Spezifikationsmöglichkeiten in besserer Weise auszudrücken.” (vlg.
\cite{wikiIntentional}) Es werden zwei Arten von DSLs unterschieden
\cite{fowler2011domain}. 

\section{Aufgabenstellung (kurz, knapp, präzise) und Erwartungen}

Das Paradigma der sprachorientierten Programmierung und die damit verbundenen
Konzepte der domänenorientierten Programmierung sollen in dieser Arbeit
analysiert und geprüft werden. 


Eine einfache DSLs soll mit Hilfe von
Groovy-Metaprogramming als interne DSLs entworfen werden.

Dabei stellen sich folgende Fragen: Wie effizient ist die Erstellung einer DSL
mittels der Programmiersprache Groovy und wie reagiert der Domänenexperte auf
die DSL?

Der Domänenexperte, die keine Erfahrung mit Programmierung haben, sollen an
interne DSLs für deren bekannte Domäne herangeführt werden, um diese
anschließend nach Lesbarkeit, intuitivem Verständnis und Flexibilität zu
bewerten. Dabei bekommt der Proband mehrere Aufgaben, die mit den
gegebenen DSLs zu lösen sind.
 
 %TODO erwartungen?
 
\section{Gliederung}

Zuerst werden theoretische Grundlagen zum Thema “Sprachorientierte
Programmierung” und Metamodellierung erläutert. Der praktische Teil beginnt mit
der Vorstellung der Problemdomäne und deren verschiedenen Anforderungen. 
Der nächste Schritt in dieser Arbeit beschäftigt sich mit der konzptionellen
Implementierung der DSL.  Weiterhin
soll die Testumgebung mit den Probanden spezifiziert werden, um danach die
Durchführung und die Ergebnisse auszuwerten und zu beschreiben.

\section{Abgrenzung}
Der Fokus dieser Arbeit soll auf die textuelle und nicht auf die graphische
Repräsentation von DSLs abzielen. “Natural language processing” soll nur
oberflächlich betrachtet werden. Der praktische Teil berichtet ausschließlich
über die Groovy-Metaprogrammierung. 
%TODO nu interne DSLs werden praktisch angewendet.s und kein MPS
\chapter{Theorie}

\section{Domain Specific Languages}
 
% Programmierer entwickeln Software überwiegend in universell einsetzbaren
% Programmiersprachen (engl.
% general purpose language, GPL), wie z.B. Java, C\#.
% Diese Sprachen sind, für nahezu jeden Anwendungszweck einsetzbar.
% Dadurch werden diese Sprachen komplex und deren Benutzung ist nur durch gut
% ausgebildete Programmierer möglich.
% Programmierer bilden Sachverhalte, Objekte und Prozesse aus der realen Welt
% mit Hilfe einer Kombination der universell einsetzbaren Konstrukte
% aus der Programmiersprache ab.
% Zur Erstellung benötigen die Entwickler Spezifikationen, die die zu erstellende
% Software genau beschreiben. Diese werden widerrum von Experten erstellt, deren
% Job es ist mit den Auftraggebern bzw. den Domänenexperten zu kommunizieren, um
% daraus eine Spezifikation abzuleiten. Diese Spezifikation ist der sogenannte
% Problemraum. Die Erstellte Software ist der Lösungsraum. 
% Um die Spezifikation wäerend oder nach der Entwicklungsphase zu verifizieren
% sind Tests notwendig.



%TODO start copy--
% Diese Art der Softwareentwicklung führt in der Praxis zu verschiedenen Proble-
% men. Es entstehen hohe Aufwände für Spezifikation und Test. Trotzdem ist die
% entwickelte Software häufig fehleranfällig und entspricht oft nicht genau den
% Spezifikationen. Nachbesserungen sind nötig, die Geld und Zeit kosten.
%  
% Domänenspezifische Sprachen können in bestimmten Situationen helfen, um diesen
% Problemen zu begegnen. Die grundsätzli- che Idee ist, ausgewählte Softwareteile
% nicht mehr mit universell einsetzbaren Programmiersprachen zu entwickeln, son-
% dern stattdessen Sprachen zu benutzen, die auf die konkrete Anwendungsdomäne
% spezialisiert sind. Der Quelltext, der mit einer solchen Sprache entwickelt
% wird, kann später vollautomatisch in den Quell- code einer universellen
% Programmierspra- che übersetzt werden. Der Vorteil ist, dass der Sprachumfang
% der DSL aufgrund der Spezialisierung auf eine Domäne im Vergleich mit einer
% universellen Sprache viel kleiner ist. Um domänenspezifische Sachverhalte als
% Quellcode auszudrücken ist deutlich weniger Zeit und Quellcode nötig, zur
% Programmierung reicht oft das  Domänenwissen des Anwendungsexperten aus. Im
% Extremfall könnte statt dem Programmierer der Anwendungsexperte das benötigte
% Programm schreiben. Die Erstellung des DSS-Quellcodes erfolgt mittels eines
% speziellen Editors, der die Sprachelemente als Textbefehle oder durch grafische
% Elemente bereitstellt.
% Ein solcher Editor kann so definiert werden, dass er, entsprechend den Vorgaben
% der Anwendungsdomäne, nur vorher festge- legte Kombinationen von Sprachelemen-
% ten zulässt und damit der Sicherstellung fachlicher Rahmenbedingungen besonders
% Rechnung trägt.
% 
% 
% Eine DSL ist in der Regel nicht dazu geeignet, komplette Anwendungen zu gene-
% rieren. Vielmehr sollte ein DSL zur Entwicklung kleinerer Anwendungsteile, die
% bestimmte Eigenschaften erfüllen, benutzt werden. Besonders sinnvoll ist der
% Einsatz einer DSL für Softwareteile, die häufig änderungen unterliegen. Dies
% ist zum Beispiel bei Produktdefinitionen, Verarbei- tungsregeln, Tarifrechnern
% und ähnlichem oft der Fall. Weiterhin sollte eine DSL nicht für Software
% verwendet werden, an die sehr hohe Performanceanforderungen gestellt werden.
% \cite{uniLeipzigTechRadar}
% % TODOD end copy ---


Eine domänenspezifische Sprache (engl. domain-specific language, DSL) ist, im
Gegensatz zu gängigen Programmiersprachen, auf ein ausgewähltes
 Problemfeld (die Domäne) spezialisiert. Sie besitzt hoch spezialisierte
Sprachelemente mit meist natürlichen Begriffe aus der Anwendungsdomäne.
Das Gegenteil einer domänenspezifischen Sprache ist eine universell einsetzbare
Programmiersprache (engl. general purpose language, GPL), wie C und Java, oder
eine universell einsetzbare Modellierungssprache, wie UML.

Mit Hilfe einer solchen Sprache können ausschliesslich Problembeschreibungen
innerhalb des jeweiligen Problemgebiets beschrieben werden.
Andere Problembereiche sollen ausgeblendet werden, damit der Domänenexperte sich
nur auf das für Ihn wichtigste in dem jeweiligen Bereich konzentrieren kann.

Der Domänenspezialist (z.B. ein Betriebswirt) ist mit dem Problembereich (z.B.
Produktpreisbildung) sehr vertraut. Die Domänensprache, z.B. zur Beschreibung
von Preisbildungskomponenten und deren Zusammenhänge, gibt dem Betriebswirt ein
mögliches Werkzeug, um die Preise für Produkte (z.B. Computerhardware) dynamisch
anzupassen. Diese DSL ist dann aber für andere Bereiche, wie z.B.
der Aufstellung des Personalschichtplans nicht einsetzbar.

Die Charakteristiken einer DSL sind vorzugsweise minimale Syntax die nur die
nötigsten Mittel zur Strukturierung benötigt um die Lesbarkeit zu erhöhen und
keine Ablenkung vom Problem zu schaffen. 
Was genau eine minimale Syntax ausmacht ist schwer messbar zu machen.
Vorzugsweise sollte die Syntax keine Redundanzen aufweisen, wie das z.B. bei
XML der Fall ist indem das offene und geschlossen element nochmals den selben
namen tragen. Als Faustregel sollte ein Zeichen bzw. eine minimale Kombination
aus mehreren Zeichen und deren Position in der DSL für eine Informationseinheit
verwendet werden. Als Zeichen sind hier insbesondere leerzeichen und
Zeilenumbrüche gemeint. Solche die auch eine angelehnte Bedeutung zu der
natürlichen Sprache haben. Z.B. Klammern, Semikolen, Kommas, Punkte, Slashes \ldots 

Fowler ist der begründeten Ansicht, dass zu einer DSL immer ein semantisches
Modell \cite[p. 159]{fowler2011domain} exsistieren sollte, das unabhängig von
der eigentlichen DSL ist aber direkt dazugehört. Es ist das Modell zu der DSL 
oder auch das Schema. Die DSL instanziiert das semantische Modell und ist damit
eine gut lesbare Form der Modellinstanziierung. Das semantische Modell hat somit
große Ähnlichkeit mir einem Domänen Modell \cite[]{fowler2003patterns}.
Vorteilhaft ist damit die klare Trennung von Angelegenheiten
\cite{Hürsch95separationof}, auf der einen Seite das Parsen der DSL durch den
Parser und auf der anderen Seite die daraus resultierenden Semantiken.
Die DSL ist damit eine Abbildung des Modells. Veränderungen können an diesem
formalen Modell separat zur DSL durchgeführt werden. Z.B. kann das semantische
Model das von einer Zustandsmaschine sein wie in Abbildung
\ref{state-machine-semantic-model} graphisch dargestellt.


\begin{figure}[h!]
	\begin{center}
	\includegraphics[width=0.7\textwidth]{pics/data-model.jpg}
	\end{center}
	\caption{Semantisches Modell einer 	Zustandsmaschine
	- neilvandyke.org/smores/ }
	\label{state-machine-semantic-model}
\end{figure}

\begin{figure}[h!]
	\begin{center}
	\includegraphics[width=0.7\textwidth]{pics/zutandsdiaGeldautomat.jpg}
	\end{center}
	\caption{Zustandsdiagramm Geldautomat
	\url{https://www.fbi.h-da.de/uploads/RTEmagicC_f2da95d8df.gif.gif} }
	\label{zutandsdiaGeldautomat.jpg}
\end{figure}

z.B. ist das Metamodell von Zuständen eines Geldautomaten das Modell einer
Zustandsmaschine (Abb. \ref{state-machine-semantic-model}). Das Zustandsdiagramm
des Geldautomaten ist damit das in Abbilung \ref{zutandsdiaGeldautomat.jpg}
dargestellte. Es beschreibt alle Zustaende und Zustandsübergänge bzw. deren
vorausgehende Ereignisse bzw. Aktionen. Eine DSL könnte dieses Semantische
Modell also Metamodell der Zustandsmaschine mit den Gegebenheiten des
Geldautomaten instanziieren. (Code Listing \ref{geldautomat.dsl}).
   
\lstinputlisting[caption={DSL Ausschnitt für ein Geldautomat},
label={geldautomat.dsl},style=default]{code/geldautomat.dsl}
 
Im Sprachsektor des Techonologieradars (Juli 2011 von
Thoughtworks)\footnote{http://www.thoughtworks.com/radar}
sind sind die domänenspezifischen Sprachen unverändert nahe dem Zentrum
angesiedelt. Thoughtworks ist der Meinung, dass DSLs eine alte Technologie ist
und bei Entwicklern einen unterschätzten Stellenwert
hat. (nach \cite{thoughtworks-tr}) Diese Quelle steht aber unter Vorbehalt in
Hinblick auf den Verkauf des Buches von Martin Fowler (Chief Scientist von
Thoughtworks) und Rebecca Parsons (CTO von Thoughtworks) über DSLs\footnote{Domain Specific
Languages, Addison Wesley 2011} 


\subsection{Unterscheidungen}

Martin Fowler unterscheidet zwischen ausprägungen solcher DSLs, indem er deren
Beziehung zu einer GPL benennt. Externe DSLs sind eigenständige und unabhängige
Sprachen die einen eigenen sepziell angefertigten Parser besitzen. 

``Sowohl die konkrete Syntax als auch die Semantik können frei definiert
werden. SQL oder reguläre Ausdrücke sind Vertreter von externen DSLs. Wenn eine
DSL innerhalb bzw.'' \cite{wikidsl}
mit einer GPL definiert wurde, nennt er diese interne DSL. Solche eingebettete
Spracherweiterungen sind mit den gegebenene Mittel der ``Wirtssprache'', oft deren Möglichkeit zur
Metaprogrammierung (Kapitel \ref{metaprogrammingLabel}), erstellt.
Vorzugsweise sind solche Wirtssprachen dynamisch typisiert wie z.B. Ruby, Groovy
oder Scala. 
``Dadurch sinkt der Implementierungsaufwand. Eine interne DSL ist immer eine echte
Untermenge einer generelleren Sprache.'' \cite{wikidsl}

DSLs die nicht in der Hostsprache implementiert sind werden trotzdem von einer
anderen Programmiersprache geparst und weiterverarbeitet. Zusätzlich ist man bei
einer separaten Sprachdefinition nicht syntaktisch eingeschränkt. Damit sind vor
allem Szenarien gemeint bei denen z.B. Methodennamen hinter die
Argumentenklammer geschrieben ist: ``(1,1)addiere'' oder sonstige nur denkbare
syntaktische Abwandlugnen.


 
% TODO vor und nachteile des jeweiligen typs.

\section{Sprachorientierte Programmierung}

Ein Programmierer einer Anwendung auf der Internet-Platform benutzt viele
Sprachen die alle für einen bestimmten Zweck eingesetzt werden. HTML für die
Struktur und CSS für die visuelle Repräsentation dieser Stuktur und SQL um Daten
aus der Datenbank abzufragen bzw. aufzuwerten. Der Entwickler muss sich dann für
ein Web-Framework entscheiden, das in einer GPL wie
Java, Ruby oder PHP geschrieben ist. Nicht zuletzt ist Javascript noch eine
zusätzliche Sprache die Client oder auch Serverseitig\footnote{nodejs.org}
eingesetzt wird. 
Das Paradigma sprachorientierte Programmierung ermuntert den Programmier dazu
eigene Sprachen zu entwerfen die den jeweiligen Problembereich explizit
beschreiben.

``Language oriented programming (LOP) is about describing a system through
multiple DSLs[\ldots]LOP is a style of development which operates about
the idea of building software around a set of DSLs''.(vlg.
\cite{fowler2005language})

Sprachorientierte Programmierung ist nach Fowlers Beschreibung als ein Vorgehen
bei dem eine Programmiersprache sich auch mehreren Unter-Programmiersprachen
zusammensetzt, deren Funktionen mit definierten Sprachmodellen beschrieben
werden.
Diese Sprachmodelle sollen die fachlichen Probleme auf eine
natürliche Art beschreiben können, ohne dabei mehr zu beschreiben als das
Fachgebiet benötigt. Dabei liegt der Fokus auf der Problembeschreibung und nicht
auf der Lösungsbeschreibung.

In dem oft zitierten Paper beschreibt Fowler ein kleines Programm, das dazu
dient Textdateien, die eine bestimmte Struktur haben in Objektinstanzen zu
überführen.
Eine EDI-Nachricht \footnote{http://en.wikipedia.org/wiki/EDIFACT} (Electronic
Data Interchange) ist ein Beispiel dafür (Listing \ref{edimsg.txt}).

\lstinputlisting[caption={EDIFACT Nachricht für einen Verfügbarkeitsanfrage},
label={edimsg.txt},style=default]{code/edimsg.txt}

Je nachdem wie z.B. die ersten drei Zeichen einer Zeile sind, wird beim
Parser eine bestimmte ``Parsing-Strategie'' angewedet. \cite{gamma1995design}
Die angewendete Strategie wird dann dazu verwendet um den Rest der Zeile
auszulesen. Diese Strategie kann zusätzlich konfiguriert werden. 
Folgendes ist nun konfigurierbar: Die ersten drei Zeichen an sich. Weithin die
Zielklasse die je nach den ersten drei Zeichen mit den restlichen Daten der
Zeile als Klassenvariablenwerte instanziiert werden soll und vor allem an
welcher Stelle der Zeile der Wert einer bestimmten Klassenvariable vorkommt.

Mit diesem kleinen Programm wurde eine Abstraktion gebaut, die durch
Konfiguration der Strategien spezifiziert werden kann.
Also um die Abstraktion zu benutzen müssen die Strategien konfiguriert werden
und deren Instanzen an den Reader-Treiber übergeben werden  (Listing
\ref{readerstrategyAndDriver}).
 

\lstinputlisting[caption={Instanzen der verschiedenen Strategien},
label={readerstrategyAndDriver},style=default]{code/readerstrategyAndDriver.java}

Da diese Konfigurationen besser konfigurierbar machen ohne immer neuen Bytecode
genierieren zu müssen könnte man eine
YAML\footnote{http://de.wikipedia.org/wiki/YAML}-Datei schreiben und diese als
Input für die Strategiekonfiguration benutzen  (Listing
\ref{readerstrategyAndDriverYAML.txt}).
 
\lstinputlisting[caption={Instanzen der verschiedenen Strategien - YAML},
label={readerstrategyAndDriverYAML.txt},style=default]{code/readerstrategyAndDriverYAML.txt}

Jemand, der den Parser und dessen Anwendung versteht, kann in kurzer Zeit etwas
mit der YAML Datei anfangen. Genau der Inhalt dieser YAML-Datei ist nun schon
eine kleine Sprache. Die konkrete Syntax ist genau das YAML Format. Eine andere
konkrete Syntax könnte das XML Format sein. Da dieses aber zu ``verbos'' ist
dient es nicht der leserlichkeit. Die Abstrakte Syntax ist nun die
Basisstruktur: ``Mehrere Abbildungen von Zeilentypen auf Klassen. Jeweils mit
den drei Buchstaben, der Zielklasse und deren Felder bzw. deren Position''.
Egal ob in XML oder in YAML, die abstrakte Syntax bleibt immer gleich.

Wenn eine minimalistische Syntax eine Vorraussetzung für eine DSL ist, kann man
die YAML-Datei auch in Ruby darstellen (Listing
\ref{readerstrategyAndDriverRuby}). Das hat zur Folge, dass der Inhalt der DSL
mit einem Ruby Interpreter gelesen und verarbeitet werden kann. Wenn auch der andere Code in Ruby geschrieben sein wuerde (Stragie
Implementation, AddFieldExtractor, AddStrategy, \ldots) dann wäre Code Listing
\ref{readerstrategyAndDriverRuby} eine interne DSL und Ruby die Wirtssprache.
Also ein Untermenge von Ruby und eine konkrete- zu unseren abstrakten
Syntax.


\lstinputlisting[caption={Instanzen der verschiedenen Strategien - RUBY},
label={readerstrategyAndDriverRuby},style=default]{code/readerstrategyAndDriverRuby.txt}

%TODO language workbenches vorstellen




\section{Groovy und Eigenschaften für eine interne DSL}

Diese Programmiersprache wurde entwurfen, um auf der JVM (Java Virtual Machine)
ausgeführt zu werden. Ruby, Python, Dylan und Smalltalk dienten als Inspiration
für die Entwickler von Groovy.

Eine Maxime für den Entwurf von Groovy war die hochgradige Kompatibilität zu
Java. Die Sprache ist auch syntaktisch stark an Java angelehnt. Wenn eine .java
Datei in eine .groovy Datei umbenannt wird, dann ist diese genau so ausführbar.
Groovy Klassen können auch von Java Klassen erben.

Groovy besitzt Eigenschaften, die sich besser als die von Java eignen, um eine
DSL zu entwerfen. Dazu zählt die wahlweise dynamische Typisierung, Closures,
native Syntax für Maps, Listen und Reguläre Ausdrücke, ein einfaches
Templatesystem, eine
XQuery-ähnliche Syntax zum Ablaufen von Objektbäumen, Operatorüberladung und
eine native Darstellung für BigDecimal und BigInteger.  

In den nächsten Abschnitten handelt diese Arbeit von den wichtigsten Features
dieser Programmiersprache, die sich für die Erstellung einer internen DSL
eignen.


\subsection{Expando}\label{expando}

Expandos sind dynamische repräsentationen von Groovy-Beans. Deren
Klassenvariablen sind über get und set erreichbar. Wenn eine Variable von einem
Expando angefragt wird und diese nicht exsistiert, dann wird
keine Exception geworfen sondern null zurückgegeben. Auch wenn eine Variable
belegt wird, dann wird diese im Expando erzeugt, wenn diese noch nicht
exsistiert. Es ist auch möglich eine Colsure einer Klassenvariable zuzuweisen.
Diese ist dann genau wie eine Methode aufrufbar. Die Notation ist ``def x =
new Expando()''

\subsection{Kategorien}

Wenn eine Methode einer bereits exsistierenden Klasse zur Laufzeit hinzugefügt
werden soll, dann erfolgt das mittels ``Kategorien''.
Um eine Methode x zu der vorhandenen Klasse java.lang.Number hinzuzufügen ist
das erstellen einer neuen Klasse mit einer statischen Methode x erforderlich.
Das erste Argument der Methode ist dann eine Referenz auf die Instanz.
Durch die Notation \texttt{use(KlasseMitStatischemX)\{x kann jetzt auf eine
Instanz von Number angewendet werden.\}}

 \subsection{Metaclass}
 
Jede Groovy Klasse implementiert die ``groovy.lang.GroovyObject''
 Schnittstelle.
Dadurch ist die Methode \texttt{getMetaClass} auf jedem Groovy-Objekt
vorhanden.
Die \texttt{MetaClass} Klasse wird dadurch referenziert.
Bei verwendeten Java-Klassen in Groovy Code ist kein solches Interface aber die
\texttt{MetaClass} wird trotzdem denen zugewiesen und in einer
\texttt{MetaClass} Registrierung \cite{fowler2003patterns}
verwaltet.
In der \texttt{MetaClass} werden alle metainformationen der eigentlichen Klasse
verwaltet. Die \texttt{MetaClass} erlaubt es neue Klassenvariablen und Methoden einem
Objekt hinzuzufügen ganz nach dem Expando (Abschnitt \ref{expando}) Prinzip.
Javaklassen beschreiben das Verhalten zur Zeit der Übersetztung, Metaklassen zur
das zür Ausführungszeit.
Die Kardinaliät Objekt und Metaklasse ist immer 1:1.
Die \texttt{MetaClass} implementiert die Methode \texttt{invokeMethod}















\section{Metaprogrammierung}\label{metaprogrammingLabel}

 

%TODO sind lisp macros auch metaprogrammierung?

% Metaprogrammierung ist eine Programmiertechnik, die Codegenerierung einsetzt, um
% bessere Abstraktion zu ermöglichen.
% Ein Evaluierer bestimmt den Wert eines formalen Ausdrucks. Z.B. ist der Wert des
% formalen Ausdrucks “5 + 3” “8”. Für Metaprogrammierung ist es oft nötig
% formale Ausdrücke zur Lauf- zeit auswerten zu können. Programmiersprachen wie
% Ruby oder Lisp stellen hierfür einen Eva- luierer über eine eval-Funktion
% bereit.
% Linguistische Abstraktion bezeichnet Abstraktion auf linguistischem
% Sprachniveau. Dabei be- zeichnet hier der Begriff “Sprache” primär formale
% Sprachen.
% Metalinguistische Abstraktion ist Abstraktion auf (linguistischem) Sprachniveau,
% die den Evalu- ierer umschreibt oder einen eigenen Evaluierer verwendet. Ein
% Beispiel ist ein lazy eval für eine strikt ausgewertete Sprache wie etwa Java.
% Der Begriff der Metalinguistischen Abstraktion ist nicht klar definiert und eine
% harte Abgrenzung zu anderen Konzepten (etwa Frameworks) vorzu- nehmen ist kaum
% möglich.
% Metaprogrammierung kann man als Werkzeug verstehen, das linguistische
% Abstraktion erzeugt.(vgl. \cite{biekermetaprogrammierung})
% 
% Metaprogrammierung bezeichnet eine Programmier-Technik um Code automatisch zu
% generie- ren. Es geht also um Code der Code schreibt.
% Der Ursprung der Metaprogrammierung geht auf das 1958 am MIT entwickelte Lisp
% bzw. Sche- me zurück. In Lisp gibt es (defmacro ..) und in Scheme (define-syntax
% ..) Makros. Ein Lisp-Makro ist einer Funktion ähnlich. Eine Funktion erhält
% Parameter und liefert einen oder mehere Werte zurück. Ein Lisp-Makro erhält
% Parameter und liefert einen oder mehere Code- Ausdrücke zurück, die wieder
% evaluiert werden.
% Vor der Entwicklung der Lisp-Makros gab es bereits selbstmodifizierenden
% Assembler-Code. Das Problem hiermit ist das zu niedrige Abstaktionsniveau, da
% man sich auf Opcode-Ebene mit der Manipulation des Codes beschäftigen muss.
% In Ruby gibt es die Methoden define method und define class, mit der man
% Methoden bzw. Klassen definieren kann. Um Metaprogrammierung betreiben zu
% können, ist es essentiel, dass man solche Funktionen hat, damit man dynamisch
% Methoden und Klassen erzeugen kann. Des Weiteren stellt Ruby eval Funktionen zur
% Verfügung, mit denen Code in unterschiedlichen Kon- texten ausgeführt werden
% kann.
% InRubywirdkomplexereMetaprogrammierungüberInterpreter-Hooksrealisert,etwamethodmissing.
% method missing wird augerufen, wenn man eine nicht vorhandene Methode auf einem
% Objekt
% aufruft.DieDefault-ImplemtierungwirfteineNoMethodErrorException.Durchüberschreiben
% dieser Method kann man z.B. ein Dateisystem Objekt erzeugen, dass als
% Methodenaufrufe sei- ne Unterordner kennt. Dies ermöglicht es z.B. ein
% Verhalten, analog zu dem Shell-Befehl cd dirname, über fsobj dirname zu
% realisieren.
% Ein anderer Interpreter-Hook ist Class.inherited, der immer ausgeführt wird,
% wenn man von einer Klasse erbt. Möchte man verhindern, dass von einer Klasse
% geerbt wird, kann man in Class.inherited eine Exception werfen.
% 
% Oft wird Metaprogrammierung als eine Form der Codekomprimierung verstanden. Es
% geht bei Metaprogrammierung nicht um das reine Einsparen von Zeichen bzw. Code-Zeilen, sondern um Abstraktion.
% 
% (vgl. \cite{biekermetaprogrammierung})
% 
% Introspection bezeichnet die Fähigkeit, auf Informationen über die Zustäe
% von Objekte, deren Klassen und Verhalten zur Laufzeit zugreifen zu können.
% Intercession erlaubt Zustände und Verhalten von Objekten, aber auch deren
% Klassen zur Laufzeit zu verändern. Intercession setzt meist Introspection
% voraus.\cite{mpInGroovy}
% 
% \section{probleme und loesungsansaetze} 
% Ich beschreibe nun einige Probleme mit Metaprogrammierung und DSLs. Es geht mir
% hier nicht um Vollständigkeit, sondern darum einige Probleme und potenzielle
% Lösungen auf zu zeigen.
% Eins der wichtigsten Probleme ist die hohe Komplexität. In [Diomidis Spinellis.
% Rational metaprogramming. IEEE Software, 25(1):78–79, January/Fe- bruary 2008.]
% beschreibt der Autor das Pro- blem wie folgt:
% “While I admire the cleverness and skill that hides behind C++ libraries (...),
% the fact remains that writing advanced template code is devilishly hard, (...)”
% Die Komplexität lässt sich durch die Verwendung bekannter Metaprog. Paradigmen
% und Patterns reduzieren. Lisp hat hier etliche zu bieten, etwa defmacro,
% Higher-Order Functions oder Currying.
% Eine DSL bzw. ein Metaprogammierungsframework sollte im mathematischen Sinne
% abgeschlos- sen sein. D.h. man soll den selben Code erzeugen können, den man von
% Hand schreiben kann und umgekehrt.
% Komplexe DSLs erzeugen teilweise schwer debugbaren Code. Nach Wissensstand des
% Autors gibt es zur Zeit kaum Lösungsansätze für dieses Problem.
% Es bleibt nur anzumerken, dass auch komplexe Frameworks teilweise schwer
% debugbaren Code erzeugen.
% Eine häufige Quelle für schwer debugbaren Code ist es, den Code als String
% darzustellen und dannzuevaluieren.Diesf ührt oft zu sinnfreien Fehlermeldungen
% wie “Syntax error in line 1 at char 42’’, wobei der evaluierte Code an anderer
% Stelle steht. Ruby und viele andere Sprachen bieten Konstrukte an, die es nicht
% zulassen, dass man syntaktisch falschen Code er- zeugt. In Ruby kann man hierfür
% Blöcke verwenden.
% Ein anderes Problem ist die Sprachkonsistens. Es ist schwierig gute und
% konsistente Sprachen zu erzeugen. Es ist aufwändig diese Sprachen zu lernen und
% ihr Support ist ressourcen-intensiv. Es macht daher Sinn die neue Sprache
% möglichst gut in die vorhandene Sprachumgebung ein zu gliedern. Eingebettete
% DSLs helfen hierbei.
% (vgl. \cite{biekermetaprogrammierung})


\subsection{groovy syntaxeigentschaften}
Omitting parentheses
Groovy allows you to omit the parentheses for top-level expressions, like with the println command:

println "Hello"
method a, b
vs:

println("Hello")
method(a, b)
When a closure is the last parameter of a method call, like when using Groovy's 'each‘ iteration mechanism, you can put the closure outside the closing parens, and even omit the parentheses:

list.each( { println it } )
list.each(){ println it }
list.each  { println it }
Always prefer the third form, which is more natural, as an empty pair of parentheses is just useless syntactical noise!

There are some cases where Groovy doesn't allow you to remove parentheses. As I said, top-level expressions can omit them, but for nested method calls or on the right-hand side of an assignment, you can't omit them there.

def foo(n) { n }

println foo 1 // won't work
def m = foo 1

\section{Metaprogrammierung in Groovy}

% 
% 
% Groovy besteht aus einem flexiblen Metaklassenmodell. Im Sinne einer Open
% Implementation hat der Programmierer nahezu alle Möglich- keiten sein Programm
% mittels Reflection zur Laufzeit zu verändern und damit an die individuellen
% Bedürfnisse anzupassen. \cite{mpInGroovy} Da Groovy auf der Java VM ausgeführt
% wird und somit auch den Grundregeln des Javaklassenmodells folgen muss,
% unterliegt es auch dessen Einschränkungen. In Java ist eine Veränderungen der
% Klassen zur Laufzeit nicht vorgesehen. Die Java Runtime Environement stellt mit
% dem java.reflect Package primär eine Mölichkeit zur Introspection bereit.
% [\ldots] 
% Erst Javassist, und Reflex erlauben echtes dynamisches
% Verhalten, in dem auf Byteco- de Ebene die Klasse verändert wird. 
% 
% Dazu muss allerdings die Klasse teilweise umständlich entladen und neugeladen
% werden. 
% Ein Meta Object Protocol auf der Java VM kann
% somit nur mittels einer zusätzlichen Indirektionsschicht realisiert werden.
% Dazu werden bestehende Konzepte von Java benutzt und um ein Metaklassenmodell
% erweitert. Aus dem Java Unterbau ergeben sich folgende Grundsätze:
% Wie in Java ist in Groovy jede Klasse abgeleitet von Object. Groovy ist in
% diesem Hinblick aber wesentlich konsequenter, da auf primitive Datentypen
% bewusst verzichtet wurde, um die Inkonsistenzen bei der Behandlung von pri-
% mitiven Datentypen und Klassen zu vermeiden. Weiterhin ist jede Klasse in Groovy
% eine Instanz von Class, womit Class alsöauch in Groovy die Klasse der Klassen
% bleibt.  \cite{mpInGroovy}
% 
% \paragraph{ getMetaClass setMetaClass} Nicht nur eine Klasse hat eine
% Metaklasse, sondern auch jedes einzelne Groovy Objekt kann eine von der Klasse
% unabhängige Metaklasse haben (siehe 2.4). Diese instanz- spezifische Metaklasse
% ist über die beiden Methoden zugänglich.\\
% 
% \paragraph{ getProperty setProperty} Properties definieren den Zustand eines
% Objektes und werden in Groovy primär auf Instanz und Klassenebene abgebildet. Jede Groovy
% Klasse kann durch Überschreiben dieser zwei Methoden dynamische Properties auf
% Objektebene oder Klassenebene erzeugen. \\
% 
% \paragraph{ invokeMethod } Das Verhalten eines Objektes ist wiederum eine Ebene
% höher angesiedelt, spielt sich alsöauf Klassen- oder Metaklassenebene ab.
% Normalerweise wird dynamisches Verhal- ten damit auf Metaklassenebene
% realisiert, sodass diese Methode der GroovyObjects gar nicht erst aufgerufen
% wird. Nur im Fehlerfall oder mit Hilfe des Tag-Interfaces GroovyInterceptable
% wird invokeMethod aufgerufen (in 2.5 genau beschrieben).
% 
% [\ldots] Während GroovyObject dynamisches Verhalten auf Objekt- und
% Klassenebene erlaubt, ist das zweite elementare Interface MetaClass die Grund-
% lage für das sehr ausgewogene Metaklassenmodell in Groovy.
% 
% \paragraph{ Metaklassen, Klassen und Instanzen} Läuft ein Programm ohne
% Intercession, sögelten für die Metaklassen der Klassen und Instanzen folgen- de
% Grundaussagen: Jede Klasse hat eine Metaklasse, die eine Instanz von Me-
% taClassImpl ist und damit MetaClass implementiert. Diese Instanzen werden
% dynamisch erzeugt und sind bis auf wenige Ausnahmen direkt MetaClassImpl
% Instanzen. Java Klassen erhalten eine Instanz von ExpandoMetaClass als Meta-
% klasse, damit auch diesen Klassen Methoden hinzugefügt werden können. Neue
% Instanzen von Klassen werden über die Metaklasse der Klasse erstellt und haben
% diese Metaklasse als Metaklasse.
% 
% 
% 
% 
%  
% \paragraph{ getProperties getMethods getMetaMethods}
% Die Methoden der Introspection in Groovy. Der Unterschied zwischen getMethods
% und getMetaMethods wird in 2.5 näher erläutert.
% \paragraph{ getClassNode}
% Liefert den AST der Metaklasse sofern verfügbar. Erlaubt auch die Modifikation
% dieses ASTs und ist damit sowohl für Introspection als auch Intercession
% geeignet. Aufgrund der Komplexität des ASTs wird allerdings dynamisches
% Verhalten häufiger über die ExpandoMetaClass realisiert und der AST verwendet,
% um Quelltextfragmente neu zu interpretieren. In den Standardbibliotheken wird so
% zum Beispiel eine Closure auto- matisch in ein SQL Statement umgewandelt, um das
% SELECT Statement performant zu benutzen.
% \paragraph{ invokeMethod}
% Jeder Methodenaufruf wird primär von der Metaklasse behandelt und entweder an
% die invokeMethod Funktion des GroovyObjects oder aber an die entsprechende
% Methode der Klasse delegiert. Das Erzeugen einer eigenen Metaklasse und
% überschreiben dieser Methode ist die Hauptmöglichkeit für dynamisches
% Verhalten in Groovy außer der ExpandoMetaClass.
% \paragraph{ getProperty setProperty}
% Die Methoden zur Property-Unterstützung auf Metaklassenebene werden von der
% Standardimplementierung von den entsprechenden Methoden von GroovyObject auf-
% gerufen. Die Aufrufreihenfolge ist im Vergleich zu invokeMethod alsögenau
% anders- herum. Auch diese Methoden sind für Intercession geeignet.
% \paragraph{ invokeMissingMethod invokeMissingProperty}
% Diese Backupmethoden werden jeweils aufgerufen, wenn die normalen Aufrufmecha-
% nismen fehlgeschlagen sind. Intercession mit diesen Methoden erlaubt zum
% Beispiel die Erweiterung von Klassen und Objekten um zusätzliche Properties zur
% Laufzeit.
%  \cite{mpInGroovy}
% 
% 
% \begin{figure}[h!]
% 	\begin{center}
% 	\includegraphics[width=0.8\textwidth]{pics/groovyMetaklassen}
% 	\end{center}
% 	\caption{Beziehung von Metaklassen, Klassen und Instanzen \cite{mpInGroovy})}
% 	\label{groovyMetaclassDiagram}
% \end{figure}




\subsection{Closures} 


\subsection{Kategorien}
% Mit Kategorien bietet Groovy eine Art dynamische Mix-ins. Es können innerhalb
% von einem Closure, beliebige Methoden zu allen Metaklassen hinzugefügt oder
% überschrieben werden.
% Die Methode use ist eine der Standardmethoden in DefaultGroovyMethods die jeder
% Metaklasse, die von MetaClassImpl erbt, automatisch hinzugefügt wird. Deswegen
% wird häufig von use auch von einem Sprachkonstrukt statt von einer Methode
% gesprochen. Mit use wird die in Klammern angegebene Klasse auf Klas- senmethoden
% untersucht und in org.codehaus.groovy.runtime.GroovyCategory- Support verwaltet.
% Es werden nur Klassenmethoden erlaubt, um Zustände in der Kategoriein- stanz zu
% vermeiden, die nicht threadsicher wären. Der this Parameter wird des- halb bei
% Üerschreiben von Instanzmethoden wie getName explizit als ersten Parameter
% angegeben. Wird nun eine Methode aufgerufen, überprüft MetaClas- sImpl in
% invokeMethod ob es eine Kategorie Methode gibt, die kompatibel ist mit dem
% aktuellen Objekt und den übergebenen Parametern. Gibt es solch eine wird der
% Aufruf delegiert, sonst wird wie in 2.5 beschrieben der normale Aufruf
% fortgesetzt.
% Kategorien sind von Objective-C entlehnt und bieten eine einfache Mög-
% lichkeit, kurzzeitig und ohne Seiteneffekte neue Methoden hinzuzufügen oder
% bestehende zu überschreiben. Sie eignen sich deswegen gut für Aspekt- oder
% Contextorientierte Programmierung. \cite{mpInGroovy}
% \subsection{Expando-MetaClass}


\chapter{MDA / MDSD und DSM Unterschiede} 
%begin copy
% Model-driven Architecture (MDA) bzw. Model-Driven Software Development (MDSD)
% und Me- taprogrammierung bzw. DSLs haben eine vergleichbare Problemstellung. In
% der MDA Welt ver- wendet man auf UML etc. basierende graphische Modele. Auch das
% graphische Model muss eine formale Sprache sein, damit es compilerbar ist. Eine
% DSL kann man als textuelle Repräsentation eines Models verstehen.
% Die Komplexität und das Abstraktionsniveau ist abhängig von dem verwendeten
% Model, nicht seiner Repräsentation. Graphische Repräsentation kann man aber
% besser mit zusätzlichen Infor- mationen anreichern, da man diese nach Bedarf
% ein- und ausblenden kann.
% Eine DSL hat den Vorteil, das ihre Darstellung simpler ist, man kann sie
% beispielsweise mit einem einfachen Text Editor bearbeiten oder mit trivialen
% Mitteln ein diff zweier Versionen erstellen (vgl. Sachez Cuadrado and
% Jesu \ldots. Building domain-specific languages for model-driven
% development. IEEE Softw., 24(5):48–55, 2007. \& Diomidis Spinellis. Rational
% metaprogramming. IEEE Software, 25(1):78–79, January/Fe- bruary 2008.).
%  (vgl. \cite{biekermetaprogrammierung})
%  %end copy
%  
%  
%  %begin copy -- wie funktioniert eine dsl
%  In unserem Beispiel mit der Uhrenanwendung sind die
% Domänenkonzepte hergeleitet aus der visuellen Anzeige (z.
% B. Zeiteinheiten, Symbole etc.), der Kontrollstruktur (Nutzer
% drückt Knopf, Alarm wird ausgelöst etc.) und darunter liegenden
% Diensten (d. h. Zeit und ihre Manipulation, Alarm). Indem
% diese Konzepte in die Modellierungssprache eingebracht und
% weiter verfeinert werden, erzeugen wir die Spezifikation der
% Sprache (d. h. das Metamodell). Das Ziel ist hier, die gewählten
% Konzepte akkurat auf die Semantik der Domäne abzubilden. \cite{dsmUhrenArtikel}
%  %end copy
%  
%  
%   
%  %begin copy -- unterschiede dsm und mda
% Wie unterscheidet sich DSM von MDA?
% Nachdem wir mit Beispielen die Hauptprinzipien von domänenspezifischer
% Modellierung demonstriert haben, können wir
% sie nun mit anderen gängigen modellbasierten Entwicklungsansätzen
% vergleichen und speziell mit der Model Driven Architecture
% (MDA) der OMG. Ganz grundsätzlich beinhaltet MDA
% die Umwandlung von UML-Modellen auf einem höheren Abstraktionsniveau
% in UML-Modelle auf einem niedrigeren Abstraktionsniveau.
% Gewöhnlich sind dies zwei Ebenen, und zwar
% plattformunabhängige Modelle (PIMs) und plattformspezifische
% Modelle (PSMs). Diese PIMs und PSMs sind reines UML
% und bieten daher keine wirkliche Erhöhung der Abstraktion.
% In der MDA werden auf jeder Stufe die Modelle einer detaillierteren
% Bearbeitung mit Reverse und Roundtrip Engineering
% unterzogen und am Ende wird wesentlicher Code aus dem finalen
% Modell generiert. Die OMG verfolgt mit MDA das Ziel,
% dasselbe PIM auf verschiedenen Software-Plattformen nutzen
% zu können. Außerdem will die OMG alle Übersetzungen und
% Modellformate standardisieren, sodass die Modelle zwischen
% den Werkzeugen verschiedener Hersteller austauschbar werden.
% Dies erreichen zu wollen, ist sehr ambitioniert, aber man
% ist noch viele Jahre davon entfernt. Diese Zielsetzung zeigt jedoch
% klar die Unterschiede zwischen DSM und MDA und beantwortet
% die Frage, wann welcher Ansatz anzuwenden ist.
% DSM erfordert Domänen-Fachwissen, ein Potenzial, das eine
% Firma nur erreichen kann, wenn sie kontinuierlich in der gleichen
% Problemdomäne arbeitet. Dies sind typischerweise eher
% Produkt- oder Systementwicklungshäuser als Projekthäuser.
% Hier ist die Plattformunabhängigkeit keine wichtige Anforderung, obwohl sie mit DSM einfach erreicht werden kann, indem
% verschiedene Code-Generatoren für verschiedene Softwareund/
% oder Produktplattformen eingesetzt werden. Stattdessen
% liegt das Hauptaugenmerk der DSM auf der signifikanten Verbesserung
% der Entwicklerproduktivität.
% Mit der MDA richtet die OMG ihren Fokus nicht auf die Nutzung
% von DSM-Sprachen, sondern auf generisches UML, ihre
% eigene Standard-Modellierungssprache. Sie versucht nicht, das
% möglicherweise existierende Domänen-Fachwissen einer Firma
% einzukapseln, sondern nimmt an, dass dieses Wissen nicht
% vorhanden oder irrelevant ist. Es scheint daher, dass die MDA,
% wenn die OMG letztlich ihre selbstgesteckten Ziele erreicht, geeignet
% für System- oder Anwendungsintegrationsprojekte ist.
% MDA setzt ein fundiertes Wissen ihrer Methodik voraus,
% welches nicht per se in einer Firma vorhanden ist und durch
% Erfahrung erlangt werden muss. Folglich muss das MDAFachwissen
% angeeignet oder von außerhalb eingekauft werden,
% wohingegen das Domänen-Fachwissen für die DSM schon in
% einer Organisation verfügbar ist und angewendet wird. In diesen
% Situationen ist die Wahl zwischen MDA und DSM oft klar.
%  \cite{dsmUhrenArtikel}
%  %end copy
%  
%  
 
\chapter{Praktischer Teil}

Im praktischen Teil soll beschrieben werden, wie eine interne DSL mit Hilfe der
Groovy-Metaprogrammierung erstellt wurde und wie der Domänenexporte darauf
reagiert hat. 

\section{Die Fachliche Domäne}
Der fachliche Bereich im gesamten Kontext ist die Hotellerie. Diese
Arbeit betrachtet die Betriebswirtschaftliche Unterdomäne
 und darin, noch spezieller die tagesabhängige Preisbildung für Hotelzimmer.

\section{Vorgehen}
Nach der Zieldefinierung soll eine Bestandsaufnahme gemacht werden um die
Rahmenbedingungen für das Experiment offenzulegen. Danach werden die
Vorüberlegungen zur Zielerreichung dargestellt und anschließend die
Implementierung der Lösung beschrieben. Daraus entstehen jeweils Unterziele die
in den einzelenen Abschnitten näher beschrieben sind. Anschliessend bietet diese
Arbeit jeweils eine Ausgewertung und Beurteilung.

\section{Zieldefinierung}
Das Ziel war es eine Sprache zu erstellen, die sich ausschließlich durch
Preisbestimmung für jeden möglichen Tag in der Zukunft bzw. für jedes Apartment
im Hotel definiert.

\section{Bestandsaufnahme}
Zuerst wurde unverbindlich eine Bestandsaufnahme gemacht. Das Hotel
``Schoenhouse Apartments'' besteht aus 50 Apartments in Berlin Mitte. Der
Geschäftsführer ist Dipl.-Ing. Immanuel Lutz (Domänenexperte). Dieser bestimmt
auch hauptsächlich die Preisbildung der Apartments. Weiterhin besitzt das Hotel ein in Java
geschriebenes Property-Management-System (PMS), das zur Verwaltung folgender
Hauptkomponenten dient: Zimmer-, Gäste-, Apartment-, Sonderleitungs- und
Preisverwaltung.
Derzeit wird ein neuartiges PMS erstellt, dass auf Groovy-und-Grails basiert.
 
 \section{Vorüberlegungen}

Die Vorüberlegung erfolgte ohne den Domänenexperten lediglich die Zustimmung
für das Experiment ``Textuelle-Preisberechnung'' war gegeben, Da der
Domänenexperte nur wenig Zeit dafür preisgeben wollte. Die Vorüberlegungen
bestanden hauptsächlich aus der Grammatikstruktur und deren Semantik. 

Die DSL soll die Geschäftslogik für die dynamische Bildung der Zimmerpreise
beschreiben. In einem Hotel sind die Preise abhängig von Faktoren wie
``Angebot und Nachfrage auf dem Markt'', Investitionskosten, Zimmerkategorie,
Nebenkosten, Rabattaktionen, Provisionen der Geschäftspartner für eine
Zimmervermittlung, Zeitraum und überschneidende Ereignisse in der Umgebung
\cite[S. 44]{hahn1993tourismuspsychologie}. Mit Ereignissen sind Veranstaltungen
oder Feiertage sowie Saisons gemeint, die die Angebot und Nachfragen beeinflussen. Bewertungen, die
das Hotel auf Buchungsportalen bekommen hat sind auch Preisentscheident. Wenn
z.B. mehrere schlechte Bewertungen abgegeben wurden und darauf nur noch wenige
Gäste Buchen muss überlegt werden, ob das mit dem Preis zu regulieren geht.
Nicht zuletzt beeinflusst die Auslastung einer Zimmerkategorie oder die
Gesamtauslastung des Hotels den Zimmerpreis. Das bedeutet, wenn nur noch ein
Zimmer im Hotel verfügbar ist, dann kann es entsprechend teuer verkauft werden.
Die Auslastung, Ereignise und die Tage bis zu den Ereignissen zusammen
kombiniert beinflussen den Preis weiter. Auch die aktuelle Liquidität des
Unternehmens kann einfluss darauf haben. Der Zimmerpreis ist auch sensibel
gegenüber den Preisen der direkten Konkurenz in der Umgebung.
Der Faktor Markt ist der wohl am schwersten zu determinierende, da er sich aus
vielen anderen Faktoren zusammensetzt. Dazu gehört z.B. die Beziehung zwischen
angebotenen Hotelzimmern und nachgefragten. Wenn die Auslastung steigt und die
Nachfrage gleich bleibt, dann resultiert das in steigende Preise.
Bei sozialen, kulturellen oder positischen ereignissen weichen die Zimmerpreise
erheblich von der ``Rac-Rate'' (Grundpreisrate) ab.
Es stellt sich als schweirig heraus, alle Faktoren deterministisch zu
modellieren, da vor allem der subjektive Geschmack oder persönliche Motivationen
der potentiellen Gäste nur über statistische Werte berechenbar sind. Genau so
ist es mit der Faktorenauswahl bei ökonomischen bzw. volkswirtschaftlichen
Werten, um die Kaufkraft der internationalen Gäste zu bestimmen.
Formal kann mit diskreten Werten modelliert werden, die in direkter Beziehung zu
dem Hotel stehen. Indirekte Beziehungen werden hier aus den oben genannten
Gründen nicht betrachtet.

Der Geschäftsführer muss genau diese Preislogik für
sein Unternehmen individuell, unabhängig und zeitnah regeln können.

\section{Erstellung der DSL}\label{erstellungDSL}
Begonnen hat die Erstellung der DSL mit der Vorstellung, dass es im PMS ein
Textbereich gibt in dem die der Text eingefügt und editiert werden kann.
Der Texteditor sollte mindestens ein ``Rich-Text-Editor'' sein, damit der
Domänenexpoerte den Text formatieren kann.
Unter dem Textbereich ist es notwenig, zwei Buttons bereitzustellen. Einen um
die DSL Live anzuwenden und einen um die DSL zu simulieren also zu testen.

Da das zukünftige PMS in Groovy und Grails erstellt wird und Groovy viele
Möglichkeiten der Metaprogrammierung und der DSL erstellung explizit hat, ist es
naheliegend, das Experiment in einer internen DSL umzusetzen. 

Aus der Zieldefinition geht hervor, dass das Resultat der Preisberechnungslogik
eine Tabelle sein muss, die für jeden Tag und jeden Zimmertyp eine Gleitkommazahl als
Preis beinhaltet (Tabelle \ref{zielDefinition}).  

\begin{table}[htpb]
  \centering
  \begin{tabular}{| l | c | r |} 
 	\hline 
  	Datum & Zimmerkategorie & Tagespreis \\
  	\hline 
	1.1.2013 &  Zimmerkategorie1 &  95.00 \\
	1.1.2013 &  Zimmerkategorie2 &  105.00 \\
	2.1.2013 &  Zimmerkategorie1 &  95.00 \\
	2.1.2013 &  Zimmerkategorie2 &  105.00 \\
	3.1.2013 &  Zimmerkategorie1 &  95.00 \\
	3.1.2013 &  Zimmerkategorie2 &  105.00 \\
	\hline 
  	\end{tabular}  
 	\caption{Zielstruktur}
  \label{zielDefinition}
\end{table}	 

Perspektivisch war der Gedanke, dass man von einer Menge alle Elemente dazu
benutzen muss, um den Preis zu bilden. Damit ist gemeint, dass sich die Tage in
einer Menge befinden und auch die Zimmerkategorien Mengenbasierend sind.
Weiterhin besteht eine Berechnungslogik zum größten Teil aus mathematischen
Ausdrücken bzw. Formeln.
Bemerkenswert ist, das die Erstellung der Domänenlogik nicht zuerst auf der
Grundlage des semantischen Modells erstellt wurde sondern rein Intuitiv auf
Basis von bekanntem Domänenwissen. Da sich das semantische Modell als das einer
Bash-Script-Sequenz mit Schleifen herausstellte, ist es nicht verwunderlich,
dass ein Programmierer mit langjähriger Erfahrung das auch ohne Schema erstellen
konnte.
Begonnen wurde mit einem TestTreiber, der eine Textdatei einliest und diese
Interpretiert bzw. evaluiert.
Cliff James hatt das in einem
Tutorial\footnote{http://www.nextinstruction.com/blog/2012/01/08/creating-dsls-with-groovy/}
bewerkstelligt und folgenden Trick angewendet:
Die DSL befindet sich innerhalb einer separaten Datei und ist nach Ausführung
des Einlesecodes in einen interpolierten String umgewandelt. Anschließend wird
dieser String in einen Closure-Block eingefügt.
Da dieser eingefügte String, innerhlab einer ``run'' Methode liegt ist der
Aufruf immer der selbe.
Die DSL wird letztendlich von der Groovy Shell Instanz evaluiert (\cite[S.
368]{koenig2007groovy}). 
Doch ohne den Kontex um die DSL, speziell ausenstehende Werte ist die DSL nutzlos. Daher wird
eine Instanz von Binding (\cite[S. 368]{koenig2007groovy}) dazu benutzt um
Variablen an das Script zu übergeben.
die Binding Instanz wird dazu benutz um die Variable run eine Closure zuzuweisen
die die loadDSL Methode im runner aufruft. Die Binding instanz wird dann an
die GroovyShell instanz übergeben um die Assoziationen zu gewährleisten (Code
Listing \ref{dslrunner.groovy}) .
Mit Groovy-Metaprogrammierung ist es möglich den Kontext einer Instanz zu
wechseln, also die Instanz einer Klasse. Delegate wechselt also zu ``this'' und
damit ist dann die DSL Bestandteil des DSLRunners. Das bedeutet, das alles was
in der DSL-Datei geschrieben wurde jetzt Methoden und Variablen der
DSLRunner-Klasse referenzieren kann.
 
\lstinputlisting[caption={DSL-Runner},
label={dslrunner.groovy},style=default]{code/dslrunner.groovy}

Da nun jedmögliche Textdatei an den DSLRunner übergeben werden konnte, um
Groovy-Script-Code auszuführen ist es dementsprechend auch möglich den Inhalt
des besagten Textfeldes als Input zu benutzen. Diese triviale Implementierung
wurde übersprungen. 
 Eine Schleifeniteration besteht aus einer List oder
einem Abschnitt (Range) gefolgt von der each Methode und der auszuführenden
Closure als Parameter für diese ``each'' Methode \ref{normalGroovyLoop.goovy}.

\lstinputlisting[caption={Orgniale Groovy Schleifenbeispiel
http://groovy.codehaus.org/Collections}, label={normalGroovyLoop.goovy},style=default]{code/normalGroovyLoop.goovy}

Die Versionkontrollhistorie zeigt, dass der erste Eintrag in der DSL aus einer
Schleife über einem Zeitraum von zwei Jahren erstellt wurde. Denn eine finale
Liste kann nur durch eine Schleifenähnliche Funktion erstellt werden
\ref{firstDSLEntry.groovy}.

\lstinputlisting[caption={erster DSL Enturf},
label={firstDSLEntry.groovy},style=default]{code/firstDSLEntry.groovy}

Durch die im theoretischen Teil vorgestellten Kategorien war es nun möglich
anstatt der speziellen Notation für zwei Jahre, bzw. die Instanziierung einer
Dauer (Duration) die Notation 2.years zu verwenden. 

Weiterhin wurde die Instanz
der \texttt{ExpandoMetaClass} der Date-Klasse (Date.metaClass) dazu verwendet,
um eine Methode namens ``bis'' für die Date-Klasse zu definieren, die wieder ein Date
Objekt als Argument entgegennimmt und daraus einen (Zeit)Abschnitt (engl.
Range, Notation: ``start..stop''  ) daraus ableitet.

Durch das Binding Objekt konnte die vordefinierte instanz (new Date()) mit dem
Variablennamen ``heute'' übergeben werden. Diese Variable konnte somit in der
DSL also als solche verwendet werden. 

Die erste Spalte der Zieltabelle ist somit darstellbar, aber die lesbarkeit war
erhelblich durch Sonderzeichen beeinträchtigt. Ziel war nun die Lesbarkeit
erheblich zu steigern indem Sonderzeichen weitestgehend eliminiert werden und
englische Begriffe durch deutsche zu ersetzen.
Zuerst wurde das wort ``each'' durch ``alle'' ersetzt. Das gelang dadurch, dass
die die Bedeutung an sich ``jedes Element'' in einer bestimmten Menge
(engl. Collection) ihren Ursprung hat. Hier wurde wiederrum das
ExpandoMetaObject dafür Benutzt um der Überklasse ``java.util.Collection'' eine
Closure für die neu definierte Eigenschaft ``alle'' zu übergeben. Die Closure
sollte nun eine Iteration über alle Elemente in der Menge leisten und dabei
nochmals eine Closure entgegennehmen in der dann die Operation auf das Element
definiert wird. Ausserdem muss der Deligierte wieder auf die Mengeninstanz
gewechselt werden. Abbilung \ref{alle.groovy} zeigt den Codeabschnitt im
DSLRunner.

\lstinputlisting[caption={Definition von [1,2].alle(\{..\})},
label={alle.groovy},style=default]{code/alle.groovy}

Weiterhin wurde aus 2.years eine neue Kategorie definiert, die die deutsche
Bezeichnung von Jahren benutzt. Also 2.jarhe oder 1.jahr.
Dazu wurde das metaClass ExpandoMetaObject von der Klasse Number
dahingehend verändert, dass solche Konstruktionen möglich werden (Code Listing
 \ref{jahre.groovy}).

\lstinputlisting[caption={Expando Metaclass Jahre},
label={jahre.groovy},style=default]{code/jahre.groovy}

Durch die vorgestellten Syntaxeigenschaften ist es möglich die Klammern
wegzulassen und damit den in Code Listing \ref{finalIterationCode.groovy}
dargestellten DSL-Code zu erzeugen.

\lstinputlisting[caption={Iterationsnotation auf Basis von Kategorien},
label={finalIterationCode.groovy},style=default]{code/finalIterationCode.groovy}

Um diesen gut lesbaren Code noch mehr an die deutsche Ausdrucksweise anzulehnen
ist die Verwendung von Command Expressions hilfreich um eine Fluid DSL zu
erstellen. Das bedeutet, dass in der deutschen Sprache eigentlich folgender
Ausdruck der natürlichste waer: ``alle Tage von heute bis in zwei Jahren
einzeln auflisten und jeden Tag immer als Tag bezeichnen.'' Nun diese ehr lange
Ausdrucksweise ist zwar prezise aber enthält gegenüber einer mit
minimalen Sonderzeichen geschriebenen Notation noch zu viele Begriffe.
Ein valider Kompromiss ist folgender: ``von heute bis 2.jahre alleTage \{ tag
-> \}''.
Dieser Kompromiss wurde ausgehend von der vorhandenen Programmiersprache in der
die DSL ``eingebettet'' sein soll und der subjektiven Empfindungsweise des
Erstellers gemacht. 
Die Präposition ``von'' ist der Name einer Methode, die als Argument ein Datum
akzeptiert und eine Methode als Rückgabewert hat.
``Von'' ist somit eine Methode höherer
Ordnung\footnote{ \url{de.wikipedia.org/wiki/Funktion_höherer_Ordnung} } und
in Code Listing \ref{fluentInterface.groovy} dargestellt.

\lstinputlisting[caption={Fluent Interface Implementierung},
label={fluentInterface.groovy},style=default]{code/fluentInterface.groovy}

Der Rückgabetyp ist eine HashMap mit ``keys'' als Methodennamen und
Closures als ``values'' bzw. dazugehörige ``Methodenkörper''.
Wenn genau das der Fall ist, ist so ein Listeneintrag widerrum ein Objekt an dem
Methoden aufgerufen werden können. Wenn eine Map zurückgegeben wird, dann
identifiziert sich der eintrag der Map anhand des Schlüssels (``bis''). Bis
referenziert somit einen Closurekörper, der ein Argument entgegennimmt das vom
Typ Date ist. Letztendlich gibt diese Closure ein Instanz von Range zurück. Der
Vorteil dabei ist, dass das Argument vom ersten Methodenaufruf (``von(datum)'')
in der Closure des zweiten Methodenaufrufs benutzt werden kann und somit dieses
``Fluent Interface'' eine abgekapselte Einheit darstellt.
Daraus folgt nun folgende Notation neue Notation für die DSL (Code Listing
\ref{finaldateRangeDSL.groovy}).
Durch triviales kopieren der ``alle'' zu ``alleTage'' ExpandoMetaObejkt Instanz
wurde nach dem DRY\footnote{Dave Thomas, interviewed by Bill Venners
(2003-10-10) http://www.artima.com/intv/dry.html} Prinzip die Closure
wiederverwendet und alleTage steht für eine Menge, genauer für eine ObjectRange zur Verfügung.

\lstinputlisting[caption={Fluent Interface Anwendung},
label={finaldateRangeDSL.groovy},style=default]{code/finaldateRangeDSL.groovy}
 
Wie in der Vorbetrachung angemerkt beziehen sich die Preise nicht nur auf den
Zeitraum sondern werden nicht jedem einzelnen Zimmer sondern einer Kategorie
zugeordnet.
Die Information aus der Hostdomäne (Abb. \ref{domainModelDia.png}) bzw. alle
Zimmerkategorien, muss nun in Verbindung mit der DSL gebracht werden.

 
\begin{figure}[h!]
	\begin{center}
	\includegraphics[width=1.3\textwidth,angle=90]{pics/domainModelDia.png}
	\end{center}
	\caption{PMS - Domänen Modell Diagramausschnitt}
	\label{domainModelDia.png}
\end{figure}

Bestenfalls sollte folgende Semantik vollkommen ausreichen:
``Hotel.Zimmerkategorien'' um die Menge abzubilden.
Das Binding Objekt erlaubt nun eine Referenzierung der Domänenmodellinstanzen
mittels dem Grails Framework. Problematisch ist die unterschiedliche Benennung
der DSL komponenten und der Domänenmodelle. Beispielsweise heisst das Hotel im
Domänenmodell ``Estate'' und in der DSL nur ``Hotel''. Wiederrum heissen die
Zimmerkategorien nicht so sondern ``EstateRoomType''. Es ist also notwendig ein
Mapping zu erstellen, dass genau diese Fälle abdeckt. Der Binding Schlüsselwert
für das Estate Objekt ist dann Hotel. 
Da aber die Zimmerkategorien auf kein Feld innerhalb des Domänenmodells
referenziert, muss ein erneutes Mapping erfolgen. Trivial wäre es in dem
Domänenobjekt eine Kopie auf ``estateRoomTypes'' zu machen. Da aber so keine
Kapselung erreichen wird ist es notwendig ein WrapperObjekt zu erstellen und das
an die DSL zu binden (Code Listing \ref{EstateDSLWrapper.groovy}).
 

\lstinputlisting[caption={EstateDSLWrapper.groovy},
label={EstateDSLWrapper.groovy},style=default]{code/EstateDSLWrapper.groovy}

Das Binding ist in Listing \ref{estateBinding.groovy} dargestellt.

\lstinputlisting[caption={estateBinding.groovy},
label={estateBinding.groovy},style=default]{code/estateBinding.groovy}

Analog dazu ist dieses Vorgehen auch mit den definierten Ereignissen
``PriceVariationRange'' durchführbar, welche aus dem Domänenmodell an die DSL
gebunden werden. Da eine Iterationsnotation (``alle'') eingeführt wurde ist es
insgesamt nun möglich {\bf Schleife}n zu schachteln Code Listing
\ref{multipleLoops.dsl}.
 
\lstinputlisting[caption={multipleLoops.dsl},
label={multipleLoops.dsl},style=default]{code/multipleLoops.dsl}

In Code Listing \ref{multipleLoops.dsl} ist Zusätzlich auch schon der erste
{\bf Ausdruck} in Zeile 4 dargestellt. Trivialer weise handelt es sich um
eine Variablendefinition inklusive {\bf Zuweisung}. Dieser Greift auf
die Iterationsvariable ``ZimmerTyp'' zu und referenziert die in dem Wrapper
festgelegte Eigenschaft Grundpreis. Im DomänenModell Estate heisst diese
Klassenvariable ``racRate''.
Die {\bf Variable} Tagespreis ist letztendlich die die modifiziert
werden soll und anschließend in die Ergebnistabelle dem Tag und der
Kategorie zugewiesen werden soll. Die Endtabelle soll in Form einer Liste
definiert werden um dann mit dem Listenoperator ( << ) diese
zu füllen. Die Listennotation ist trivialerweise folgende: ``listenname = []''.

Bisher wurden alle Informationen beschrieben um eine finale implementierung
durchzuführen. Code Listing \ref{trivialSolution.groovy} zeigt, das die
Zielstellung dahingehen erreicht ist, das eine Liste wie in Tabelle \ref{zielDefinition} durch
die DSL berechnet wird.
 
\lstinputlisting[caption={Triviale Lösung des Problems},
label={trivialSolution.groovy},style=default]{code/trivialSolution.groovy}

Das Resultat kann automatisch und transparent gegenüber dem Domänenexperten
durch ein XML oder JSON Mapping an die ``PartnerChannels'' (Booking.com oder HRS) geschickt werden.
Das zu implementieren ist nicht Bestandteil dieser Arbeit.

Da das Grundgerüst der DSL damit geschaffen ist erfolt nun die Anpassung des
Tagespreises durch {\bf Formel}n und {\bf Bedingung}en.

Da der Domänenexperte höchstwahrscheinlich mit Prozenten arbeiten will sollte
es für denjenigen möglich sein diese Zahlen{\bf funktion} einfach benutzen zu
können. Mit Hilfe von Kategorien ist es möglich das zu bewerkstelligen um
letztendlich folgendes DSL
Wort\footnote{http://de.wikipedia.org/wiki/Wort\_\(Theoretische_Informatik\)}
zu erstellen: ``10 prozent Tagespreis''
die Kategorie dazu lautet ist in Code Listing \ref{EnhancedNumber.groovy}
dargestellt.
 
\lstinputlisting[caption={Kategoriedefinition für Prozent},
label={EnhancedNumber.groovy},style=default]{code/EnhancedNumber.groovy}

Wie in der Vorüberlegung schon angedeutet gibt es z.B. eine Preiserhöhung wenn
ein bestimmtes Ereignis eingetroffen ist. So ein wiederkehrendes
Ereignis ist z.B. ein Wochenende. Wenn also der Domänenexperte sich dazu
entscheidet den Preis am Wochenende um 10\% anzuheben sollte er folgendes in der
DSL schreiben können: ``wochenendaufschlag = wenn tag.wochenende dann 10 prozent
tagesPreis''. Wieder wurde hier die Methode eines Fluent Interfaces benutzt wie
bei der Zeitabschnittbestimmung (von(x).bis(y)). In Listing
\ref{ifelseCase.groovy}
 
\lstinputlisting[caption={DSL - if else Ausdruck},
label={ifelseCase.groovy},style=default]{code/ifelseCase.groovy}

Diese Wenn dann Kombination ist wie an der 0 zu erkennen nur für Formeln
einsetztbar. 
Alle Zusätzlichen Erweiterungen für die Date-Klasse sind in Code Listing
\ref{completeDateMetaClass.groovy} dargestellt. Darunter befindet sich auch die
Erweiterung ``getWochenende bzw. wochenende''.

\lstinputlisting[caption={Erweiterungen für die Date-Klasse},
label={completeDateMetaClass.groovy},style=default]{code/completeDateMetaClass.groovy}
 
Dem Domänenexperten wird nun unterstellt, dass er x += 1 als Summierung für x =
x + 1 erlerenen kann. Letztendlich wäre er nun in der Lage folgenden Ausdruck zu
schreiben: ``TagesPreis += wenn Tag.wochenende dann 10 prozent TagesPreis''.
 
Weiter könnte sich der Hotelbetreiber dazu entscheiden folgende modifikation an
dem Tagespreis durchzuführen: Je nach dem wie das Hotel prozentual ausgelastet
ist, wird der Tagespreis, um diesen prozentualen Anteil von einem drittel des
Grundpreises, erhöht oder verringert.
Wieder durch die Binding-Möglichkeit können weitere vordefinierte Variablen
übergeben werden. Z.B. ``binding.gesamtzimmer =
Estate.estateRoomTypes*.count()'' und weiterhin die Anzahl der freien
Zimmer als Methode (Code Listing \ref{predefinedVars.groovy}) 

\lstinputlisting[caption={Vordefinierte Variablen},
label={predefinedVars.groovy},style=default]{code/predefinedVars.groovy}
 
Abschließend soll hier noch weiter die Möglichkeit vorgestellt werden wie auf
die vorher erwähnten bzw. vordefinierten Ereignisse zugegriffen werden kann um
eine Tagespreismanipulation durchzuführen.
Code Listing \ref{finalDSLComplete.dsl} zeigt eine mögliche Form der DSL in der ca. 90\% der
Konzepte Beispielhaft dargestellt sind.  

\lstinputlisting[caption={DSL Beispiel},
label={finalDSLComplete.dsl},style=default]{code/finalDSLComplete.dsl}

Dabei sei nochmal auf die besondere Konstruktion hingewiesen ``tage von: heute,
bis: ereignis.start''. Das ist eine spezielle Notation in Groovy namens
``named parameters''. ``tage'' ist eine Methode, die zwei Parameter entgegennimmt.
``von'' und ``bis'', die auch so benannt werden müssen. Durch das Entfernen der
klammern ist jetzt die dahinterliegenede Struktur zu erkennen. Die Alternative hinter dem Ausdrück im
Kommentar (Zeile 15) ist anders aufgebaut. ``abstand'' ist nun eine Methode, die
eine Closure als Argument entgegennimmt, in diesem Fall einen Abschnitt
(Range).

\section{Das semantischen Modell}

Im Kapitel \ref{erstellungDSL} wurde beschrieben wie die DSL erstellt wurde.
Dabei wurden einige Begriff in bold markiert um die wichtigsten
Meta-Bestandteile unterschwellig zu verdeutlichen. In Abbilung \ref{mm.png}
ist deren Zusammensetztung bzw. das semantische Modell der Preisberechnung
dargestellt.
Dieses ist sehr stark an das einer Skriptsprache angeleht.
In diesem Modell sind nur Berechnungsbestandteile durch Asdrücke und Schleifen
definiert. In einer Scriptsprache ist darüber hinaus noch mehr möglich.
 
\begin{figure}[h!]
	\begin{center}
	\includegraphics[width=0.99\textwidth]{pics/mm}
	\end{center}
	\caption{Preisberechnung semantisches Modell}
	\label{mm.png}
\end{figure}

Die Erstellung dieses Modells, wurde nach der Erstellung der DSL gefertigt um
daraus z.B. eine bessere Dokumentation zu erstellen, die dem Domänenexperten
hilft die DSL zu erstellen.
  
In Abbildung \ref{mmInstanz.png} ist ein Instanzdiagram, der ersten DSL
Zeilen, um das Semantische Modell zu verifizieren.
Durch die Codezeilen-Eigenschaft eines Berechnungsbestandteils kann die
Abarbeitungssequenz dargestellt werden. Die drei Schleifen werden abgebildet und
einzelen Ausdrücke innerhalb der Schleifen, wie z.B. ``wenn TagInnerhalbEreignis
dann 10 prozent tagesPreis'' oder ``Tagespreis = Zimmertyp.Grundpreis''. Die
grau markierte Instanz soll darstellen, das es sich um ein und das selbe
handelt. 

\begin{figure}[h!]
	\begin{center}
	\includegraphics[width=0.99\textwidth]{pics/mmInstanz}
	\end{center}
	\caption{Instanzdiagram der ersten Codezeilen}
	\label{mmInstanz.png}
\end{figure}
 
\chapter{Auswertung}
 
\subsection{Wahl der DSL Variante}
Bewertung des Probands: Lesbarkeit, intuitivem Verständnis und Flexibilität

\subsection{Beurteilung des Domänenexperten}

\subsection{Beurteilung der Meta-Programmierungstools von Grovvy} 
Einfacher da kein aufwand für gui zu betreiben ist.
 
\chapter{Zusammenfassung und Schlussbetrachtung}

 %begin copy -- unterschiede dsm und mda
% Domänenspezifische Modellierung erlaubt schnellere Entwicklung
% basierend auf den Modellen der Problemdomäne und weniger auf
% Modellen von Quellcode. Unser Uhrenbeispiel veranschaulichte dies
% schnell. Industrielle Erfahrungen mit DSM [DSM] zeigen bedeutende
% Verbesserungen der Produktivität, niedrigere Entwicklungskosten
% und bessere Qualität. Das Unternehmen Nokia gibt beispielsweise
% an, dass sich die Entwicklung von Mobiltelefonen auf
% diesem Weg um den Faktor 10 beschleunigt. Bei der Firma Lucent
% konnte die Produktivität – abhängig vom Produkt – um das drei- bis
% zehnfache gesteigert werden. Die Schlüsselfaktoren dafür sind:
% H Das Problem wird nur einmal – und zwar auf einem hohen
% Abstraktionsniveau – gelöst und der lauffähige Quellcode
% wird geradewegs aus dieser Lösung generiert.
% H Das Hauptaugenmerk der Entwickler liegt nicht länger auf dem
% Code, sondern beim Modell, dem Problem an sich. Komplexität
% und Implementierungsdetails können so verborgen werden und
% eine bereits bekannte Terminologie rückt in den Vordergrund.
% H Durch eine einheitlichere Entwicklungsumgebung und dadurch,
% dass weniger Wechsel zwischen den Abstraktionsniveaus
% Modell und Implementierung erforderlich sind, lassen
% sich eine bessere Konsistenz der verschiedenen Produkte
% und niedrigere Fehlerraten erreichen.
% H Das Domänenwissen wird für das Entwicklungsteam explizit
% gemacht, indem es in der Modellierungssprache und deren
% Werkzeugunterstützung festgehalten wird.
% Der Einsatz von DSM bedeutet keine zusätzliche Investition,
% wenn der gesamte Zyklus vom Design bis zum arbeitenden
% Code betrachtet wird. Vielmehr spart es Entwicklungsressourcen:
% Traditionell arbeiten alle Entwickler mit den Konzepten der
% Problemdomäne und bilden diese von Hand auf die Implementierungskonzepte
% ab. Aber unter den Entwicklern gibt es große
% Unterschiede. Manche erledigen diese Aufgabe besser, manche
% schlechter. Also lasst die erfahrenen Entwickler die Konzepte
% und deren Abbildung einmal definieren, dann müssen die anderen
% dies nicht erneut tun. Spezifiziert ein Experte den Code-
% Generator, so produziert dieser Anwendungen von besserer
% Qualität, als es normale Entwickler von Hand könnten.
 \cite{dsmUhrenArtikel}
 %end copy
 
 
\bibliographystyle{alphadin}
\clearpage\addcontentsline{toc}{chapter}{\bibname}\bibliography{jabref}
\appendix
\renewcommand{\theequation}{A-\arabic{equation}}

\setcounter{equation}{0}  % reset counter \chapter*{Anhang}  % use *-form to

%\chapter{Anhang}
\addcontentsline{toc}{chapter}{Anhang}

%\section{Anhang A - Screenshots}\label{appendixA}


%\listoffigures
\end{document}
