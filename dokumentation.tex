

\documentclass[11pt,english,ngerman, headsepline]{scrreprt}
\usepackage{lmodern}
\renewcommand{\sfdefault}{lmss}
\renewcommand{\ttdefault}{lmtt}
\usepackage[T1]{fontenc}

\usepackage{listings}

\usepackage[utf8]{inputenc} \usepackage[a4paper]{geometry}
\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=3cm,rmargin=2.75cm,headheight=1cm,headsep=0.666cm,footskip=1cm}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{babel}
  \usepackage{tipa}
\usepackage{verbatim} 
\usepackage{float}  
\usepackage{url}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage[square,sort,numbers]{natbib} \usepackage[utf8]{inputenc}
\usepackage{graphicx} 
\usepackage[xindy,toc]{glossaries}

 
 
\input{formating/formating.tex}

\parindent 0pt

\begin{document} 


\input{deckblatt/deckblatt.tex}

\selectlanguage{ngerman}%
\tableofcontents{}

\pagestyle{scrheadings}    %Kopfzeile ein


% ==========================================================================
% DOCUMENT START
% ==========================================================================

\chapter{Einleitung} 

Die Sektionen würden bei der echten Arbeit wegfallen.

\section{Motivation (Heranführen an das Thema)}

Das Wort “Abstraktion” bezeichnet meist den induktiven Denkprozess des
Weglassens von Einzelheiten und des Überführens auf etwas Allgemeineres oder
Einfacheres [...] alsö[...] jenen Prozess, der Informationen söweit auf ihre
wesentlichen Eigenschaften herab setzt, dass sie psychisch überhaupt weiter
verarbeitet werden können. (nach \cite{wikiAbsraktion}) Die grundlegenden
Abstraktionsstufen in der Informatik sind wie folgt aufgeteilt: Die unterste
Ebene ohne Abstraktion ist die der elektronischen Schaltkreise, die elektrische
Signale erzeugen, kombinieren und speichern. Darauf aufbauend existiert die
Schaltungslogik. Die dritte Abstraktionsschicht ist die der Rechnerarchitektur.
Danach kommt eine der obersten Abstraktionsschichten: “Die Sicht des
Programmierers”, der den Rechner nur noch als Gerät ansieht, das Daten speichert
und Befehle ausführt, dessen technischen Aufbau er aber nicht mehr im Einzelnen
zu berücksichtigen braucht. (nach S. 67 \cite{rechenberg2000informatik}). Diese
Beschreibung von Abstraktion lässt sich auch auf Programmiersprachen übertragen.
Nur wenige programmieren heute direkt Maschinencode, weil die
Programmiersprachen der dritten Generation (3GL) soviel Abstraktionsgrad bieten,
dass zwar kein bestimmtes Problem aber dessen Lösung beschrieben werden kann.
Die Lösung des Problems muss genau in der Sprache beschrieben werden und setzt
das Verständnis und die Erfahrung in der Programmiersprache und deren
Eigenheiten zur Problemlösung voraus. Das Verständnis des eigentlichen Problems,
dass es mit Hilfe von Software zu lösen gilt, liegt nicht immer zu 100% bei dem
Programmierer, der es mit Java oder C\# bzw. einer 3GL lösen soll. Komplexe
Probleme z.B. in der Medizin, der Architektur oder im Versicherungswesen sind
oft söumfangreich, dass die Aufgabe des “Requirements Engeneering”
hauptsächlich darin besteht, zwischen dem Auftragnehmer und Auftraggeber eine
Verständnisbrücke zu bauen. Diese Brücke ist auf der einen Seite mit
Implementierungsdetails belastet und auf der anderen mit domänenspezifischem
Wissen (Fach- oder Expertenwissen). Die Kommunikation der beiden Seiten kann
langfristig durch eine DSL begünstigt werden, da eine Abstrahierung des
domänenspezifischen Problems angestrebt wird. Die Isolation der eigentlichen
Businesslogik und eine intuitiv verständliche Darstellung in textueller Form
kann sogar soweit gehen, dass der Domänenexperte die Logik in hohem Maße selbst
implementieren kann, weil er nicht mit den Implementierungsdetails derselben und
den syntaktischen Gegebenheiten einer turingvollständigen
General-Purpose-Language wie Java oder C\# abgelenkt wird. Im Idealfall kann er
die gewünschten Anforderungen besser abbilden.(vlg. \cite{heiseMPS2}). Beispiele
für DSL sind z.B.: Musiknoten auf einem Notenblatt, Morsecode oder
Schachfigurbewegungen (“Bauer e2-e4”) bis hin zu folgendem Satz: “wenn (Kunde
Vorzugsstatus hat) und (Bestellung Anzahl ist größer als 1000 oder Bestellung
ist neu) dann ... ”. “Eine domänenspezifische Sprache ist nichts anderes als
eine Programmiersprache für eine Domäne. Sie besteht im Kern aus einem
Metamodell einer abstrakten Syntax, Constraints (Statischer Semantik) und einer
konkreten Syntax. Eine festgelegte Semantik weist den Sprachelementen eine
Bedeutung zu.” (vlg. S.30 \cite{mdaDPunkt})

\section{Begriffserklärung (falls notwendig)}
Eine DSL beinhaltet ein Metamodell. In einer Domänengrammatik gibt es das
Konzept an sich, das beschrieben werden soll. Konzepte können Daten, Strukturen
oder Anweisungen bzw. Verhalten und Bedingungen sein. Das Metamodell oder auch
das Semantische Modell besteht aus einem Netzwerk vieler Konzepte. Das Paradigma
“Language Orientated Programming” (LOP) identifiziert ein Vorgehen in der
Programmierung, bei dem ein Problem nicht mit einer GPL (general purpose
language) angegangen wird, sondern bei dem zuerst domänenspezifische Sprachen
entworfen werden, um dann durch diese das Problem zu lösen. Zu diesem Paradigma
gehört auch die Entwicklung von domänenorientierten Sprachen und intuitive
Programmierung (intentional programming). “Intentionale Programmierung ist ein
Programmierparadigma. Sie bezeichnet den Ansatz, vom herkömmlichen Quelltext als
alleinige Spezifikation eines Programms abzurücken, um die Intentionen des
Programmierers durch eine Vielfalt von jeweils geeigneten
Spezifikationsmöglichkeiten in besserer Weise auszudrücken.” (vlg.
\cite{wikiIntentional}) Es werden zwei Arten von DSLs unterschieden
\cite{fowler2010domain}. Eine interne DSL ist eine in die “General Purpose
Language” eingebettete “Spracherweiterung”, die sich mit den gegebenen Mitteln
der Wirtssprache und deren Möglichkeit zur Metaprogrammierung erstellen lässt.
Vorzugsweise sind solche Wirtssprachen dynamisch typisiert wie z.B. Ruby, Groovy
oder Scala. Eine externe DSL ist völlig eigenständig und besitzt einen eigenen
Parser und kann, ohne die “Einschränkungen” einer Wirtssprache, beliebig
definiert werden.

\section{Aufgabenstellung (kurz, knapp, präzise) und Erwartungen}

Anhand mehrerer Problemfälle soll das Paradigma der sprachorientierten
Programmierung und die damit verbundenen Konzepte der domänenorientierten
Programmierung analysiert und geprüft werden. Mehrere vergleichsweise einfache
DSLs sollen mit Hilfe von Groovy-Metaprogramming als interne DSLs bzw. mit dem
Meta-Programming-System (MPS) sollen überschaubare externe DSLs entworfen
werden. Domänenexperten, die keine Erfahrung mit Programmierung haben, sollen an
interne bzw. externe DSLs für deren bekannte Domäne herangeführt werden, um
diese anschließend nach Lesbarkeit, intuitivem Verständnis und Flexibilität zu
bewerten. Dabei bekommen die Probanden mehrere Aufgaben, die sie mit den
gegebenen DSLs lösen sollen.
Die Erwartungen sind, dass bei kleinen Systemen, der Aufwand zu hoch ist, extraeine DSL einzusetzten. Bei komplexen Systemen stellt eine geeignete DSL jedocheinen unmittelbaren Mehrwert dar.

\section{Gliederung}

Zuerst werden theoretische Grundlagen zum Thema “Sprachorientierte
Programmierung” und Metamodellierung erläutert. Der praktische Teil beginnt mit
der Vorstellung der Problemdomänen und deren verschiedenen Anforderungen. Dann
werden die zu implementierenden DSLs konzeptionell vorgestellt. Die Umsetzung
dieser Konzepte mit den Toolsets wird im nächsten Kapitel beschrieben. Weiterhin
soll die Testumgebung mit den Probanden spezifiziert werden, um danach die
Durchführung und die Ergebnisse auszuwerten und zu beschreiben.


\section{Abgrenzung}
Der Fokus dieser Arbeit soll auf die textuelle und nicht auf die graphische
Repräsentation von DSLs abzielen. “Natural language processing” soll nur
oberflächlich betrachtet werden. Domänenspezifische Modellierung mit UML soll
nur am Rande betrachtet werden. Als Toolset sollen ausschließlich MPS und
Groovy-Meta-Programming verwendet werden.
\chapter{Theorie}

\section{Domain Specific Languages}

\subsection{Unterscheidungen}

\section{Sprachorientierte Programmierung}

``Language oriented programming is about describing a system through multiple
DSLs''.(vlg. \cite{fowler2005language})

Sprachorientierte Programmierung ist nach Fowlers Beschreibung alsöein
gesamtsystem bestehend aus subsystemen, deren Funktionen mit definierten
Sprachmodellen beschrieben werden. Bestenfalls sollten diese Sprachmodelle
die fachlichen Probleme auf eine natürliche Art beschreiben können ohne dabei
mehr zu beschreiben als das Fachgebiet benötigt.

\section{Groovy}

Groovy ist eine dynamisch typisierte Programmiersprache und Skriptsprache für
die Java Virtual Machine.
Groovy besitzt einige Fähigkeiten, die in Java nicht vorhanden sind: Closures,
native Syntax für Maps, Listen und Reguläre Ausdrücke, ein einfaches
Templatesystem, mit dem HTML- und SQL-Code erzeugt werden kann, eine
XQuery-ähnliche Syntax zum Ablaufen von Objektbäumen, Operatorüberladung und
eine native Darstellung für BigDecimal und BigInteger. (vgl. \cite{wikigroovy})



\section{Metaprogrammierung}


Metaprogrammierung ist eine Programmiertechnik, die Codegenerierung einsetzt, um
bessere Abstraktion zu ermöglichen.
Ein Evaluierer bestimmt den Wert eines formalen Ausdrucks. Z.B. ist der Wert des
formalen Ausdrucks “5 + 3” “8”. Für Metaprogrammierung ist es oft nötig
formale Ausdrücke zur Lauf- zeit auswerten zu können. Programmiersprachen wie
Ruby oder Lisp stellen hierfür einen Eva- luierer über eine eval-Funktion
bereit.
Linguistische Abstraktion bezeichnet Abstraktion auf linguistischem
Sprachniveau. Dabei be- zeichnet hier der Begriff “Sprache” primär formale
Sprachen.
Metalinguistische Abstraktion ist Abstraktion auf (linguistischem) Sprachniveau,
die den Evalu- ierer umschreibt oder einen eigenen Evaluierer verwendet. Ein
Beispiel ist ein lazy eval für eine strikt ausgewertete Sprache wie etwa Java.
Der Begriff der Metalinguistischen Abstraktion ist nicht klar definiert und eine
harte Abgrenzung zu anderen Konzepten (etwa Frameworks) vorzu- nehmen ist kaum
möglich.
Metaprogrammierung kann man als Werkzeug verstehen, das linguistische
Abstraktion erzeugt.(vgl. \cite{biekermetaprogrammierung})

Metaprogrammierung bezeichnet eine Programmier-Technik um Code automatisch zu generie- ren. Es geht also um Code der Code schreibt.
Der Ursprung der Metaprogrammierung geht auf das 1958 am MIT entwickelte Lisp bzw. Sche- me zurück. In Lisp gibt es (defmacro ..) und in Scheme (define-syntax ..) Makros. Ein
Lisp-Makro ist einer Funktion ähnlich. Eine Funktion erhält Parameter und liefert einen oder mehere Werte zurück. Ein Lisp-Makro erhält Parameter und liefert einen oder mehere Code- Ausdrücke zurück, die wieder evaluiert werden.
Vor der Entwicklung der Lisp-Makros gab es bereits selbstmodifizierenden Assembler-Code. Das Problem hiermit ist das zu niedrige Abstaktionsniveau, da man sich auf Opcode-Ebene mit der Manipulation des Codes beschäftigen muss.
In Ruby gibt es die Methoden define method und define class, mit der man Methoden bzw. Klassen definieren kann. Um Metaprogrammierung betreiben zu können, ist es essentiel, dass man solche Funktionen hat, damit man dynamisch Methoden und Klassen erzeugen kann. Des Weiteren stellt Ruby eval Funktionen zur Verfügung, mit denen Code in unterschiedlichen Kon- texten ausgeführt werden kann.
InRubywirdkomplexereMetaprogrammierungüberInterpreter-Hooksrealisert,etwamethodmissing. method missing wird augerufen, wenn man eine nicht vorhandene Methode auf einem Objekt aufruft.DieDefault-ImplemtierungwirfteineNoMethodErrorException.Durchüberschreiben
dieser Method kann man z.B. ein Dateisystem Objekt erzeugen, dass als Methodenaufrufe sei-
ne Unterordner kennt. Dies ermöglicht es z.B. ein Verhalten, analog zu dem Shell-Befehl cd dirname, über fsobj dirname zu realisieren.
Ein anderer Interpreter-Hook ist Class.inherited, der immer ausgeführt wird, wenn man von einer Klasse erbt. Möchte man verhindern, dass von einer Klasse geerbt wird, kann man in Class.inherited eine Exception werfen.

Oft wird Metaprogrammierung als eine Form der Codekomprimierung verstanden. Es
geht bei Metaprogrammierung nicht um das reine Einsparen von Zeichen bzw. Code-Zeilen, sondern um Abstraktion.

(vgl. \cite{biekermetaprogrammierung})

Introspection bezeichnet die Fähigkeit, auf Informationen über die Zustäe
von Objekte, deren Klassen und Verhalten zur Laufzeit zugreifen zu können.
Intercession erlaubt Zustände und Verhalten von Objekten, aber auch deren
Klassen zur Laufzeit zu verändern. Intercession setzt meist Introspection
voraus.\cite{mpInGroovy}

\section{probleme und loesungsansaetze} 
Ich beschreibe nun einige Probleme mit Metaprogrammierung und DSLs. Es geht mir
hier nicht um Vollständigkeit, sondern darum einige Probleme und potenzielle
Lösungen auf zu zeigen.
Eins der wichtigsten Probleme ist die hohe Komplexität. In [Diomidis Spinellis.
Rational metaprogramming. IEEE Software, 25(1):78–79, January/Fe- bruary 2008.]
beschreibt der Autor das Pro- blem wie folgt:
“While I admire the cleverness and skill that hides behind C++ libraries (...),
the fact remains that writing advanced template code is devilishly hard, (...)”
Die Komplexität lässt sich durch die Verwendung bekannter Metaprog. Paradigmen
und Patterns reduzieren. Lisp hat hier etliche zu bieten, etwa defmacro,
Higher-Order Functions oder Curry- ing.
Eine DSL bzw. ein Metaprogammierungsframework sollte im mathematischen Sinne
abgeschlos- sen sein. D.h. man soll den selben Code erzeugen können, den man von
Hand schreiben kann und umgekehrt.
Komplexe DSLs erzeugen teilweise schwer debugbaren Code. Nach Wissensstand des
Autors gibt es zur Zeit kaum Lösungsansätze für dieses Problem.
Es bleibt nur anzumerken, dass auch komplexe Frameworks teilweise schwer
debugbaren Code erzeugen.
Eine häufige Quelle für schwer debugbaren Code ist es, den Code als String
darzustellen und dannzuevaluieren.Diesf ührt oft zu sinnfreien Fehlermeldungen
wie “Syntax error in line 1 at char 42’’, wobei der evaluierte Code an anderer
Stelle steht. Ruby und viele andere Sprachen bieten Konstrukte an, die es nicht
zulassen, dass man syntaktisch falschen Code er- zeugt. In Ruby kann man hierfür
Blöcke verwenden.
Ein anderes Problem ist die Sprachkonsistens. Es ist schwierig gute und
konsistente Sprachen zu erzeugen. Es ist aufwändig diese Sprachen zu lernen und
ihr Support ist ressourcen-intensiv. Es macht daher Sinn die neue Sprache
möglichst gut in die vorhandene Sprachumgebung ein zu gliedern. Eingebettete
DSLs helfen hierbei.
(vgl. \cite{biekermetaprogrammierung})

\section{Metaprogrammierung in Groovy}
Groovy besteht aus einem flexiblen Metaklassenmodell. Im Sinne einer Open
Implementation hat der Programmierer nahezu alle Möglich- keiten sein Programm
mittels Reflection zur Laufzeit zu verändern und damit an die individuellen
Bedürfnisse anzupassen. \cite{mpInGroovy} Da Groovy auf der Java VM ausgeführt
wird und somit auch den Grundregeln des Javaklassenmodells folgen muss,
unterliegt es auch dessen Einschränkungen. In Java ist eine Veränderungen der
Klassen zur Laufzeit nicht vorgesehen. Die Java Runtime Environement stellt mit
dem java.reflect Package primär eine Mölichkeit zur Introspection bereit.
[\ldots] 
Erst Javassist, und Reflex erlauben echtes dynamisches
Verhalten, in dem auf Byteco- de Ebene die Klasse verändert wird. 

Dazu muss allerdings die Klasse teilweise umständlich entladen und neugeladen
werden. 
Ein Meta Object Protocol auf der Java VM kann
somit nur mittels einer zusätzlichen Indirektionsschicht realisiert werden.
Dazu werden bestehende Konzepte von Java benutzt und um ein Metaklassenmodell
erweitert. Aus dem Java Unterbau ergeben sich folgende Grundsätze:
Wie in Java ist in Groovy jede Klasse abgeleitet von Object. Groovy ist in
diesem Hinblick aber wesentlich konsequenter, da auf primitive Datentypen
bewusst verzichtet wurde, um die Inkonsistenzen bei der Behandlung von pri-
mitiven Datentypen und Klassen zu vermeiden. Weiterhin ist jede Klasse in Groovy
eine Instanz von Class, womit Class alsöauch in Groovy die Klasse der Klassen
bleibt.  \cite{mpInGroovy}

\paragraph{ getMetaClass setMetaClass} Nicht nur eine Klasse hat eine
Metaklasse, sondern auch jedes einzelne Groovy Objekt kann eine von der Klasse
unabhängige Metaklasse haben (siehe 2.4). Diese instanz- spezifische Metaklasse
ist über die beiden Methoden zugänglich.\\

\paragraph{ getProperty setProperty} Properties definieren den Zustand eines
Objektes und werden in Groovy primär auf Instanz und Klassenebene abgebildet. Jede Groovy
Klasse kann durch Überschreiben dieser zwei Methoden dynamische Properties auf
Objektebene oder Klassenebene erzeugen. \\

\paragraph{ invokeMethod } Das Verhalten eines Objektes ist wiederum eine Ebene
höher angesiedelt, spielt sich alsöauf Klassen- oder Metaklassenebene ab.
Normalerweise wird dynamisches Verhal- ten damit auf Metaklassenebene
realisiert, sodass diese Methode der GroovyObjects gar nicht erst aufgerufen
wird. Nur im Fehlerfall oder mit Hilfe des Tag-Interfaces GroovyInterceptable
wird invokeMethod aufgerufen (in 2.5 genau beschrieben).

[\ldots] Während GroovyObject dynamisches Verhalten auf Objekt- und
Klassenebene erlaubt, ist das zweite elementare Interface MetaClass die Grund-
lage für das sehr ausgewogene Metaklassenmodell in Groovy.

\paragraph{ Metaklassen, Klassen und Instanzen} Läuft ein Programm ohne
Intercession, sögelten für die Metaklassen der Klassen und Instanzen folgen- de
Grundaussagen: Jede Klasse hat eine Metaklasse, die eine Instanz von Me-
taClassImpl ist und damit MetaClass implementiert. Diese Instanzen werden
dynamisch erzeugt und sind bis auf wenige Ausnahmen direkt MetaClassImpl
Instanzen. Java Klassen erhalten eine Instanz von ExpandoMetaClass als Meta-
klasse, damit auch diesen Klassen Methoden hinzugefügt werden können. Neue
Instanzen von Klassen werden über die Metaklasse der Klasse erstellt und haben
diese Metaklasse als Metaklasse.




 
\paragraph{ getProperties getMethods getMetaMethods}
Die Methoden der Introspection in Groovy. Der Unterschied zwischen getMethods
und getMetaMethods wird in 2.5 näher erläutert.
\paragraph{ getClassNode}
Liefert den AST der Metaklasse sofern verfügbar. Erlaubt auch die Modifikation
dieses ASTs und ist damit sowohl für Introspection als auch Intercession
geeignet. Aufgrund der Komplexität des ASTs wird allerdings dynamisches
Verhalten häufiger über die ExpandoMetaClass realisiert und der AST verwendet,
um Quelltextfragmente neu zu interpretieren. In den Standardbibliotheken wird so
zum Beispiel eine Closure auto- matisch in ein SQL Statement umgewandelt, um das
SELECT Statement performant zu benutzen.
\paragraph{ invokeMethod}
Jeder Methodenaufruf wird primär von der Metaklasse behandelt und entweder an
die invokeMethod Funktion des GroovyObjects oder aber an die entsprechende
Methode der Klasse delegiert. Das Erzeugen einer eigenen Metaklasse und
überschreiben dieser Methode ist die Hauptmöglichkeit für dynamisches
Verhalten in Groovy außer der ExpandoMetaClass.
\paragraph{ getProperty setProperty}
Die Methoden zur Property-Unterstützung auf Metaklassenebene werden von der
Standardimplementierung von den entsprechenden Methoden von GroovyObject auf-
gerufen. Die Aufrufreihenfolge ist im Vergleich zu invokeMethod alsögenau
anders- herum. Auch diese Methoden sind für Intercession geeignet.
\paragraph{ invokeMissingMethod invokeMissingProperty}
Diese Backupmethoden werden jeweils aufgerufen, wenn die normalen Aufrufmecha-
nismen fehlgeschlagen sind. Intercession mit diesen Methoden erlaubt zum
Beispiel die Erweiterung von Klassen und Objekten um zusätzliche Properties zur
Laufzeit.
 \cite{mpInGroovy}


\begin{figure}[h!]
	\begin{center}
	\includegraphics[width=0.8\textwidth]{pics/groovyMetaklassen}
	\end{center}
	\caption{Beziehung von Metaklassen, Klassen und Instanzen \cite{mpInGroovy})}
	\label{groovyMetaclassDiagram}
\end{figure}




\subsection{Closures} 


\subsection{Kategorien}
Mit Kategorien bietet Groovy eine Art dynamische Mix-ins. Es können innerhalb
von einem Closure, beliebige Methoden zu allen Metaklassen hinzugefügt oder
überschrieben werden.
Die Methode use ist eine der Standardmethoden in DefaultGroovyMethods die jeder
Metaklasse, die von MetaClassImpl erbt, automatisch hinzugefügt wird. Deswegen
wird häufig von use auch von einem Sprachkonstrukt statt von einer Methode
gesprochen. Mit use wird die in Klammern angegebene Klasse auf Klas- senmethoden
untersucht und in org.codehaus.groovy.runtime.GroovyCategory- Support verwaltet.
Es werden nur Klassenmethoden erlaubt, um Zustände in der Kategoriein- stanz zu
vermeiden, die nicht threadsicher wären. Der this Parameter wird des- halb bei
Üerschreiben von Instanzmethoden wie getName explizit als ersten Parameter
angegeben. Wird nun eine Methode aufgerufen, überprüft MetaClas- sImpl in
invokeMethod ob es eine Kategorie Methode gibt, die kompatibel ist mit dem
aktuellen Objekt und den übergebenen Parametern. Gibt es solch eine wird der
Aufruf delegiert, sonst wird wie in 2.5 beschrieben der normale Aufruf
fortgesetzt.
Kategorien sind von Objective-C entlehnt und bieten eine einfache Mög-
lichkeit, kurzzeitig und ohne Seiteneffekte neue Methoden hinzuzufügen oder
bestehende zu überschreiben. Sie eignen sich deswegen gut für Aspekt- oder
Contextorientierte Programmierung. \cite{mpInGroovy}
\subsection{Expando-MetaClass}


\chapter{MDA / MDSD und Metaprogrammierung} 
Model-driven Architecture (MDA) bzw. Model-Driven Software Development (MDSD)
und Me- taprogrammierung bzw. DSLs haben eine vergleichbare Problemstellung. In
der MDA Welt ver- wendet man auf UML etc. basierende graphische Modele. Auch das
graphische Model muss eine formale Sprache sein, damit es compilerbar ist. Eine
DSL kann man als textuelle Repräsentation eines Models verstehen.
Die Komplexität und das Abstraktionsniveau ist abhängig von dem verwendeten
Model, nicht seiner Repräsentation. Graphische Repräsentation kann man aber
besser mit zusätzlichen Infor- mationen anreichern, da man diese nach Bedarf
ein- und ausblenden kann.
Eine DSL hat den Vorteil, das ihre Darstellung simpler ist, man kann sie
beispielsweise mit einem einfachen Text Editor bearbeiten oder mit trivialen
Mitteln ein diff zweier Versionen erstellen (vgl. Sachez Cuadrado and
Jesu \ldots. Building domain-specific languages for model-driven
development. IEEE Softw., 24(5):48–55, 2007. \& Diomidis Spinellis. Rational
metaprogramming. IEEE Software, 25(1):78–79, January/Fe- bruary 2008.).
 (vgl. \cite{biekermetaprogrammierung})
 
\chapter{Praktischer Teil}

\section{Die Fachliche Domäne}

\chapter{Auswertung}

\chapter{Zusammenfassung und Schlussbetrachtung}



\bibliographystyle{alphadin}
\clearpage\addcontentsline{toc}{chapter}{\bibname}\bibliography{jabref}
\appendix
\renewcommand{\theequation}{A-\arabic{equation}}

\setcounter{equation}{0}  % reset counter \chapter*{Anhang}  % use *-form to

%\chapter{Anhang}
\addcontentsline{toc}{chapter}{Anhang}

%\section{Anhang A - Screenshots}\label{appendixA}


%\listoffigures
\end{document}
